# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `karafka-core` gem.
# Please instead update this file by running `bin/tapioca gem karafka-core`.


# Karafka framework main namespace
#
# source://karafka-core//lib/karafka/core.rb#3
module Karafka
  class << self
    # source://karafka/2.4.2/lib/karafka.rb#94
    def boot_file; end

    # source://karafka/2.4.2/lib/karafka.rb#63
    def core_root; end

    # source://karafka/2.4.2/lib/karafka.rb#25
    def env; end

    # source://karafka/2.4.2/lib/karafka.rb#33
    def env=(environment); end

    # source://karafka/2.4.2/lib/karafka.rb#53
    def gem_root; end

    # source://karafka/2.4.2/lib/karafka.rb#38
    def logger; end

    # source://karafka/2.4.2/lib/karafka.rb#48
    def monitor; end

    # source://karafka/2.4.2/lib/karafka.rb#68
    def pro?; end

    # source://karafka/2.4.2/lib/karafka.rb#43
    def producer; end

    # source://karafka/2.4.2/lib/karafka.rb#74
    def rails?; end

    # source://karafka/2.4.2/lib/karafka.rb#103
    def refresh!; end

    # source://karafka/2.4.2/lib/karafka.rb#58
    def root; end
  end
end

# Namespace for small support modules used throughout the Karafka ecosystem
#
# source://karafka-core//lib/karafka/core.rb#5
module Karafka::Core
  class << self
    # @return [String] root path of this gem
    #
    # source://karafka-core//lib/karafka/core.rb#8
    def gem_root; end
  end
end

# A simple dry-configuration API compatible module for defining settings with defaults and a
# constructor.
#
# source://karafka-core//lib/karafka/core/configurable.rb#7
module Karafka::Core::Configurable
  include ::Karafka::Core::Configurable::InstanceMethods

  mixes_in_class_methods ::Karafka::Core::Configurable::ClassMethods

  class << self
    # Sets up all the class methods and inits the core root node.
    # Useful when only per class settings are needed as does not include instance methods
    #
    # @param base [Class] class that we extend
    #
    # source://karafka-core//lib/karafka/core/configurable.rb#17
    def extended(base); end

    # Sets up all the class and instance methods and inits the core root node
    #
    # Needs to be used when per instance configuration is needed
    #
    # @param base [Class] class to which we want to add configuration
    #
    # source://karafka-core//lib/karafka/core/configurable.rb#26
    def included(base); end
  end
end

# Class related methods
#
# source://karafka-core//lib/karafka/core/configurable.rb#47
module Karafka::Core::Configurable::ClassMethods
  # @return [Node] root node for the settings
  #
  # source://karafka-core//lib/karafka/core/configurable.rb#49
  def config; end

  # Allows for a per class configuration (if needed)
  #
  # @param block [Proc] block for configuration
  #
  # source://karafka-core//lib/karafka/core/configurable.rb#62
  def configure(&block); end

  # source://karafka-core//lib/karafka/core/configurable.rb#70
  def setting(*_arg0, **_arg1, &_arg2); end
end

# Instance related methods
#
# source://karafka-core//lib/karafka/core/configurable.rb#33
module Karafka::Core::Configurable::InstanceMethods
  # @return [Node] config root node
  #
  # source://karafka-core//lib/karafka/core/configurable.rb#35
  def config; end

  # Allows for a per instance configuration (if needed)
  #
  # @param block [Proc] block for configuration
  #
  # source://karafka-core//lib/karafka/core/configurable.rb#41
  def configure(&block); end
end

# Single end config value representation
#
# source://karafka-core//lib/karafka/core/configurable/leaf.rb#7
class Karafka::Core::Configurable::Leaf < ::Struct
  # Returns the value of attribute compiled
  #
  # @return [Object] the current value of compiled
  def compiled; end

  # Sets the attribute compiled
  #
  # @param value [Object] the value to set the attribute compiled to.
  # @return [Object] the newly set value
  def compiled=(_); end

  # @return [Boolean] true if already compiled
  #
  # source://karafka-core//lib/karafka/core/configurable/leaf.rb#9
  def compiled?; end

  # Returns the value of attribute constructor
  #
  # @return [Object] the current value of constructor
  def constructor; end

  # Sets the attribute constructor
  #
  # @param value [Object] the value to set the attribute constructor to.
  # @return [Object] the newly set value
  def constructor=(_); end

  # Returns the value of attribute default
  #
  # @return [Object] the current value of default
  def default; end

  # Sets the attribute default
  #
  # @param value [Object] the value to set the attribute default to.
  # @return [Object] the newly set value
  def default=(_); end

  # Returns the value of attribute lazy
  #
  # @return [Object] the current value of lazy
  def lazy; end

  # Sets the attribute lazy
  #
  # @param value [Object] the value to set the attribute lazy to.
  # @return [Object] the newly set value
  def lazy=(_); end

  # @return [Boolean] is this a lazy evaluated leaf
  #
  # source://karafka-core//lib/karafka/core/configurable/leaf.rb#14
  def lazy?; end

  # Returns the value of attribute name
  #
  # @return [Object] the current value of name
  def name; end

  # Sets the attribute name
  #
  # @param value [Object] the value to set the attribute name to.
  # @return [Object] the newly set value
  def name=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# Single non-leaf node
# This is a core component for the configurable settings
#
# The idea here is simple: we collect settings (leafs) and children (nodes) information and
# we only compile/initialize the values prior to user running the `#configure` API. This API
# needs to run prior to using the result stuff even if there is nothing to configure
#
# source://karafka-core//lib/karafka/core/configurable/node.rb#12
class Karafka::Core::Configurable::Node
  # @param name [Symbol] node name
  # @param nestings [Proc] block for nested settings
  # @return [Node] a new instance of Node
  #
  # source://karafka-core//lib/karafka/core/configurable/node.rb#20
  def initialize(name, nestings = T.unsafe(nil)); end

  # We need to be able to redefine children for deep copy
  #
  # source://karafka-core//lib/karafka/core/configurable/node.rb#16
  def children; end

  # We need to be able to redefine children for deep copy
  #
  # source://karafka-core//lib/karafka/core/configurable/node.rb#16
  def children=(_arg0); end

  # Converts the settings definitions into end children
  #
  # @note It runs once, after things are compiled, they will not be recompiled again
  #
  # source://karafka-core//lib/karafka/core/configurable/node.rb#95
  def compile; end

  # Allows for the configuration and setup of the settings
  #
  # Compile settings, allow for overrides via yielding
  #
  # @return [Node] returns self after configuration
  # @yield [_self]
  # @yieldparam _self [Karafka::Core::Configurable::Node] the object that the method was called on
  #
  # source://karafka-core//lib/karafka/core/configurable/node.rb#49
  def configure; end

  # Deep copies all the children nodes to allow us for templates building on a class level
  # and non-side-effect usage on an instance/inherited.
  #
  # @return [Node] duplicated node
  #
  # source://karafka-core//lib/karafka/core/configurable/node.rb#76
  def deep_dup; end

  # Returns the value of attribute name.
  #
  # source://karafka-core//lib/karafka/core/configurable/node.rb#13
  def name; end

  # Returns the value of attribute nestings.
  #
  # source://karafka-core//lib/karafka/core/configurable/node.rb#13
  def nestings; end

  # Allows for a single leaf or nested node definition
  #
  # @param name [Symbol] setting or nested node name
  # @param default [Object] default value
  # @param constructor [#call, nil] callable or nil
  # @param lazy [Boolean] is this a lazy leaf
  # @param block [Proc] block for nested settings
  #
  # source://karafka-core//lib/karafka/core/configurable/node.rb#35
  def setting(name, default: T.unsafe(nil), constructor: T.unsafe(nil), lazy: T.unsafe(nil), &block); end

  # @return [Hash] frozen config hash representation
  #
  # source://karafka-core//lib/karafka/core/configurable/node.rb#56
  def to_h; end

  private

  # Defines a lazy evaluated read and writer that will re-evaluate in case value constructor
  # evaluates to `nil` or `false`. This allows us to define dynamic constructors that
  # can react to external conditions to become expected value once this value is
  # available
  #
  # @param value [Leaf]
  #
  # source://karafka-core//lib/karafka/core/configurable/node.rb#141
  def build_dynamic_accessor(value); end

  # Runs the constructor with or without the default depending on its arity and returns the
  # result
  #
  # @param value [Leaf]
  #
  # source://karafka-core//lib/karafka/core/configurable/node.rb#159
  def call_constructor(value); end
end

# Contract layer for the Karafka ecosystem
# It aims to be "dry-validation" like but smaller and easier to handle + without dependencies
#
# It allows for nested validations, etc
#
# @note It is thread-safe to run but validations definitions should happen before threads are
#   used.
#
# source://karafka-core//lib/karafka/core/contractable/contract.rb#5
module Karafka::Core::Contractable; end

# Base contract for all the contracts that check data format
#
# @note This contract does NOT support rules inheritance as it was never needed in Karafka
#
# source://karafka-core//lib/karafka/core/contractable/contract.rb#9
class Karafka::Core::Contractable::Contract
  extend ::Karafka::Core::Configurable
  extend ::Karafka::Core::Configurable::ClassMethods

  # Runs the validation
  #
  # @param data [Hash] hash with data we want to validate
  # @return [Result] validaton result
  #
  # source://karafka-core//lib/karafka/core/contractable/contract.rb#75
  def call(data); end

  # @param data [Hash] data for validation
  # @param error_class [Class] error class that should be used when validation fails
  # @raise [StandardError] any error provided in the error_class that inherits from the
  #   standard error
  # @return [Boolean] true
  #
  # source://karafka-core//lib/karafka/core/contractable/contract.rb#97
  def validate!(data, error_class); end

  private

  # Tries to dig for a given key in a hash and returns it with indication whether or not it was
  # possible to find it (dig returns nil and we don't know if it wasn't the digged key value)
  #
  # @param data [Hash]
  # @param keys [Array<Symbol>]
  # @return [Array<Symbol, Object>] array where the first element is `:match` or `:miss` and
  #   the digged value or nil if not found
  #
  # source://karafka-core//lib/karafka/core/contractable/contract.rb#166
  def dig(data, keys); end

  # Runs validation for rules on fields that are optional and adds errors (if any) to the
  # errors array
  #
  # @param data [Hash] input hash
  # @param rule [Rule] validation rule
  # @param errors [Array] array with errors from previous rules (if any)
  #
  # source://karafka-core//lib/karafka/core/contractable/contract.rb#133
  def validate_optional(data, rule, errors); end

  # Runs validation for rules on fields that are required and adds errors (if any) to the
  # errors array
  #
  # @param data [Hash] input hash
  # @param rule [Rule] validation rule
  # @param errors [Array] array with errors from previous rules (if any)
  #
  # source://karafka-core//lib/karafka/core/contractable/contract.rb#113
  def validate_required(data, rule, errors); end

  # Runs validation for rules on virtual fields (aggregates, etc) and adds errors (if any) to
  # the errors array
  #
  # @param data [Hash] input hash
  # @param rule [Rule] validation rule
  # @param errors [Array] array with errors from previous rules (if any)
  #
  # source://karafka-core//lib/karafka/core/contractable/contract.rb#151
  def validate_virtual(data, rule, errors); end

  class << self
    # Allows for definition of a scope/namespace for nested validations
    #
    # @example
    #   nested(:key) do
    #   required(:inside) { |inside| inside.is_a?(String) }
    #   end
    # @param path [Symbol] path in the hash for nesting
    # @param block [Proc] nested rule code or more nestings inside
    #
    # source://karafka-core//lib/karafka/core/contractable/contract.rb#29
    def nested(path, &block); end

    # @param keys [Array<Symbol>] single or full path
    # @param block [Proc] validation rule
    #
    # source://karafka-core//lib/karafka/core/contractable/contract.rb#48
    def optional(*keys, &block); end

    # Defines a rule for a required field (required means, that will automatically create an
    # error if missing)
    #
    # @param keys [Array<Symbol>] single or full path
    # @param block [Proc] validation rule
    #
    # source://karafka-core//lib/karafka/core/contractable/contract.rb#41
    def required(*keys, &block); end

    # @return [Array<Rule>] all the validation rules defined for a given contract
    #
    # source://karafka-core//lib/karafka/core/contractable/contract.rb#18
    def rules; end

    # @note Virtual rules have different result expectations. Please see contracts or specs for
    #   details.
    # @param block [Proc] validation rule
    #
    # source://karafka-core//lib/karafka/core/contractable/contract.rb#57
    def virtual(&block); end

    private

    # Initializes nestings and rules building accumulator
    #
    # source://karafka-core//lib/karafka/core/contractable/contract.rb#65
    def init_accu; end
  end
end

# Representation of a validaton result with resolved error messages
#
# source://karafka-core//lib/karafka/core/contractable/result.rb#7
class Karafka::Core::Contractable::Result
  # Builds a result object and remaps (if needed) error keys to proper error messages
  #
  # @param errors [Array<Array>] array with sub-arrays with paths and error keys
  # @param contract [Object] contract that generated the error
  # @return [Result] a new instance of Result
  #
  # source://karafka-core//lib/karafka/core/contractable/result.rb#14
  def initialize(errors, contract); end

  # Returns the value of attribute errors.
  #
  # source://karafka-core//lib/karafka/core/contractable/result.rb#8
  def errors; end

  # @return [Boolean] true if no errors
  #
  # source://karafka-core//lib/karafka/core/contractable/result.rb#38
  def success?; end

  private

  # Builds message based on the error messages
  #
  # @param contract [Object] contract for which we build the result
  # @param scope [Symbol] path to the key that has an error
  # @param error_key [Symbol] error key for yaml errors lookup
  # @return [String] error message
  #
  # source://karafka-core//lib/karafka/core/contractable/result.rb#49
  def build_message(contract, scope, error_key); end
end

# Representation of a single validation rule
#
# source://karafka-core//lib/karafka/core/contractable/rule.rb#7
class Karafka::Core::Contractable::Rule < ::Struct
  # Returns the value of attribute path
  #
  # @return [Object] the current value of path
  def path; end

  # Sets the attribute path
  #
  # @param value [Object] the value to set the attribute path to.
  # @return [Object] the newly set value
  def path=(_); end

  # Returns the value of attribute type
  #
  # @return [Object] the current value of type
  def type; end

  # Sets the attribute type
  #
  # @param value [Object] the value to set the attribute type to.
  # @return [Object] the newly set value
  def type=(_); end

  # Returns the value of attribute validator
  #
  # @return [Object] the current value of validator
  def validator; end

  # Sets the attribute validator
  #
  # @param value [Object] the value to set the attribute validator to.
  # @return [Object] the newly set value
  def validator=(_); end

  class << self
    def [](*_arg0); end
    def inspect; end
    def keyword_init?; end
    def members; end
    def new(*_arg0); end
  end
end

# Namespace for some small utilities used across the ecosystem
#
# source://karafka-core//lib/karafka/core/helpers/time.rb#6
module Karafka::Core::Helpers; end

# Time related methods used across Karafka
#
# source://karafka-core//lib/karafka/core/helpers/time.rb#8
module Karafka::Core::Helpers::Time
  # @return [Float] current time in float
  #
  # source://karafka-core//lib/karafka/core/helpers/time.rb#15
  def float_now; end

  # @return [Float] current monotonic time in milliseconds
  #
  # source://karafka-core//lib/karafka/core/helpers/time.rb#10
  def monotonic_now; end
end

# All the instrumentation shared across Karafka ecosystem
#
# source://karafka-core//lib/karafka/core/instrumentation.rb#6
module Karafka::Core::Instrumentation
  class << self
    # Builds a manager for error callbacks
    #
    # @return [Karafka::Core::Instrumentation::CallbacksManager]
    #
    # source://karafka-core//lib/karafka/core/instrumentation.rb#16
    def error_callbacks; end

    # Builds a manager for oauth bearer token refreshes
    #
    # @return [Karafka::Core::Instrumentation::CallbacksManager]
    #
    # source://karafka-core//lib/karafka/core/instrumentation.rb#22
    def oauthbearer_token_refresh_callbacks; end

    # Builds a manager for statistics callbacks
    #
    # @return [Karafka::Core::Instrumentation::CallbacksManager]
    #
    # source://karafka-core//lib/karafka/core/instrumentation.rb#10
    def statistics_callbacks; end
  end
end

# This manager allows us to register multiple callbacks into a hook that is suppose to support
# a single callback
#
# source://karafka-core//lib/karafka/core/instrumentation/callbacks_manager.rb#9
class Karafka::Core::Instrumentation::CallbacksManager
  # @return [::Karafka::Core::Instrumentation::CallbacksManager]
  #
  # source://karafka-core//lib/karafka/core/instrumentation/callbacks_manager.rb#11
  def initialize; end

  # Adds a callback to the manager
  #
  # @param id [String] id of the callback (used when deleting it)
  # @param callable [#call] object that responds to a `#call` method
  #
  # source://karafka-core//lib/karafka/core/instrumentation/callbacks_manager.rb#30
  def add(id, callable); end

  # Invokes all the callbacks registered one after another
  #
  # @note We do not use `#each_value` here on purpose. With it being used, we cannot dispatch
  #   callbacks and add new at the same time. Since we don't know when and in what thread
  #   things are going to be added to the manager, we need to extract values into an array and
  #   run it. That way we can add new things the same time.
  # @param args [Object] any args that should go to the callbacks
  #
  # source://karafka-core//lib/karafka/core/instrumentation/callbacks_manager.rb#22
  def call(*args); end

  # Removes the callback from the manager
  #
  # @param id [String] id of the callback we want to remove
  #
  # source://karafka-core//lib/karafka/core/instrumentation/callbacks_manager.rb#36
  def delete(id); end
end

# Monitoring for Karafka and WaterDrop
# It allows us to have a layer that can work with `dry-monitor` as well as
# `ActiveSupport::Notifications` or standalone depending on the case. Thanks to that we do not
# have to rely on third party tools that could break.
#
# source://karafka-core//lib/karafka/core/monitoring.rb#10
module Karafka::Core::Monitoring; end

# Single notification event wrapping payload with id
#
# source://karafka-core//lib/karafka/core/monitoring/event.rb#7
class Karafka::Core::Monitoring::Event
  # @param id [String, Symbol] id of the event
  # @param payload [Hash] event payload
  # @return [Event] a new instance of Event
  #
  # source://karafka-core//lib/karafka/core/monitoring/event.rb#12
  def initialize(id, payload); end

  # Hash access to the payload data (if present)
  #
  # @param name [String, Symbol]
  #
  # source://karafka-core//lib/karafka/core/monitoring/event.rb#20
  def [](name); end

  # Returns the value of attribute id.
  #
  # source://karafka-core//lib/karafka/core/monitoring/event.rb#8
  def id; end

  # Returns the value of attribute payload.
  #
  # source://karafka-core//lib/karafka/core/monitoring/event.rb#8
  def payload; end
end

# Karafka monitor that can be used to pass through instrumentation calls to selected
# notifications bus.
#
# It provides abstraction layer that allows us to use both our internal notifications as well
# as `ActiveSupport::Notifications`.
#
# source://karafka-core//lib/karafka/core/monitoring/monitor.rb#11
class Karafka::Core::Monitoring::Monitor
  # @param notifications_bus [Object] either our internal notifications bus or
  #   `ActiveSupport::Notifications`
  # @param namespace [String, nil] namespace for events or nil if no namespace
  # @return [Monitor] a new instance of Monitor
  #
  # source://karafka-core//lib/karafka/core/monitoring/monitor.rb#20
  def initialize(notifications_bus, namespace = T.unsafe(nil)); end

  # Passes the instrumentation block (if any) into the notifications bus
  #
  # @param event_id [String, Symbol] event id
  # @param payload [Hash]
  # @param block [Proc] block we want to instrument (if any)
  #
  # source://karafka-core//lib/karafka/core/monitoring/monitor.rb#31
  def instrument(event_id, payload = T.unsafe(nil), &block); end

  # Allows us to subscribe to the notification bus
  #
  # @param args [Array] any arguments that the notification bus subscription layer accepts
  # @param block [Proc] optional block for subscription
  #
  # source://karafka-core//lib/karafka/core/monitoring/monitor.rb#41
  def subscribe(*args, &block); end
end

# Empty has to save on objects allocation
#
# source://karafka-core//lib/karafka/core/monitoring/monitor.rb#13
Karafka::Core::Monitoring::Monitor::EMPTY_HASH = T.let(T.unsafe(nil), Hash)

# A simple notifications layer for Karafka ecosystem that aims to provide API compatible
# with both `ActiveSupport::Notifications` and `dry-monitor`.
#
# We do not use any of them by default as our use-case is fairly simple and we do not want
# to have too many external dependencies.
#
# source://karafka-core//lib/karafka/core/monitoring/notifications.rb#11
class Karafka::Core::Monitoring::Notifications
  include ::Karafka::Core::Helpers::Time

  # @return [Notifications] a new instance of Notifications
  #
  # source://karafka-core//lib/karafka/core/monitoring/notifications.rb#24
  def initialize; end

  # Clears all the subscribed listeners
  #
  # source://karafka-core//lib/karafka/core/monitoring/notifications.rb#42
  def clear; end

  # Allows for code instrumentation
  # Runs the provided code and sends the instrumentation details to all registered listeners
  #
  # @example Instrument some code
  #   instrument('sleeping') do
  #   sleep(1)
  #   end
  # @param event_id [String] id of the event
  # @param payload [Hash] payload for the instrumentation
  # @param block [Proc] instrumented code
  # @raise [EventNotRegistered]
  # @return [Object] whatever the provided block (if any) returns
  #
  # source://karafka-core//lib/karafka/core/monitoring/notifications.rb#94
  def instrument(event_id, payload = T.unsafe(nil), &block); end

  # Returns the value of attribute name.
  #
  # source://karafka-core//lib/karafka/core/monitoring/notifications.rb#14
  def name; end

  # Registers a new event on which we can publish
  #
  # @param event_id [String] event id
  #
  # source://karafka-core//lib/karafka/core/monitoring/notifications.rb#34
  def register_event(event_id); end

  # Allows for subscription to an event
  # There are two ways you can subscribe: via block or via listener.
  #
  # @example Subscribe using listener
  #   subscribe(MyListener.new)
  # @example Subscribe via block
  #   subscribe do |event|
  #   puts event
  #   end
  # @param event_id_or_listener [Object] event id when we want to subscribe to a particular
  #   event with a block or listener if we want to subscribe with general listener
  # @param block [Proc] block of code if we want to subscribe with it
  #
  # source://karafka-core//lib/karafka/core/monitoring/notifications.rb#62
  def subscribe(event_id_or_listener, &block); end

  private

  # Measures time taken to execute a given block and returns it together with the result of
  # the block execution
  #
  # source://karafka-core//lib/karafka/core/monitoring/notifications.rb#120
  def measure_time_taken; end
end

# Empty hash for internal referencing
#
# source://karafka-core//lib/karafka/core/monitoring/notifications.rb#20
Karafka::Core::Monitoring::Notifications::EMPTY_HASH = T.let(T.unsafe(nil), Hash)

# Raised when someone wants to publish event that was not registered
#
# source://karafka-core//lib/karafka/core/monitoring/notifications.rb#17
class Karafka::Core::Monitoring::Notifications::EventNotRegistered < ::StandardError; end

# Many of the librdkafka statistics are absolute values instead of a gauge.
# This means, that for example number of messages sent is an absolute growing value
# instead of being a value of messages sent from the last statistics report.
# This decorator calculates the diff against previously emited stats, so we get also
# the diff together with the original values
#
# It adds two extra values to numerics:
#   - KEY_d - delta of the previous value and current
#   - KEY_fd - freeze duration - describes how long the delta remains unchanged (zero)
#              and can be useful for detecting values that "hang" for extended period of time
#              and do not have any change (delta always zero). This value is in ms for the
#              consistency with other time operators we use.
#
# source://karafka-core//lib/karafka/core/monitoring/statistics_decorator.rb#18
class Karafka::Core::Monitoring::StatisticsDecorator
  include ::Karafka::Core::Helpers::Time

  # @return [StatisticsDecorator] a new instance of StatisticsDecorator
  #
  # source://karafka-core//lib/karafka/core/monitoring/statistics_decorator.rb#26
  def initialize; end

  # @note We modify the emited statistics, instead of creating new. Since we don't expose
  #   any API to get raw data, users can just assume that the result of this decoration is
  #   the proper raw stats that they can use
  # @param emited_stats [Hash] original emited statistics
  # @return [Hash] emited statistics extended with the diff data
  #
  # source://karafka-core//lib/karafka/core/monitoring/statistics_decorator.rb#38
  def call(emited_stats); end

  private

  # Appends the result of the diff to a given key as long as the result is numeric
  #
  # @param previous [Hash] previous scope
  # @param current [Hash] current scope
  # @param key [Symbol] key based on which we were diffing
  # @param result [Object] diff result
  #
  # source://karafka-core//lib/karafka/core/monitoring/statistics_decorator.rb#95
  def append(previous, current, key, result); end

  # Calculates the diff of the provided values and modifies in place the emited statistics
  #
  # @param previous [Object] previous value from the given scope in which
  #   we are
  # @param current [Object] current scope from emitted statistics
  # @return [Object] the diff if the values were numerics or the current scope
  #
  # source://karafka-core//lib/karafka/core/monitoring/statistics_decorator.rb#62
  def diff(previous, current); end
end

# Empty hash for internal referencing
#
# source://karafka-core//lib/karafka/core/monitoring/statistics_decorator.rb#22
Karafka::Core::Monitoring::StatisticsDecorator::EMPTY_HASH = T.let(T.unsafe(nil), Hash)

# Patches to dependencies and components
#
# source://karafka-core//lib/karafka/core/patches/rdkafka/bindings.rb#6
module Karafka::Core::Patches; end

# Patches to rdkafka
#
# source://karafka-core//lib/karafka/core/patches/rdkafka/bindings.rb#8
module Karafka::Core::Patches::Rdkafka; end

# Extends `Rdkafka::Bindings` with some extra methods and updates callbacks that we intend
# to work with in a bit different way than rdkafka itself
#
# source://karafka-core//lib/karafka/core/patches/rdkafka/bindings.rb#11
module Karafka::Core::Patches::Rdkafka::Bindings
  class << self
    # @return [FFI::Function] overwritten callback function
    #
    # source://karafka-core//lib/karafka/core/patches/rdkafka/bindings.rb#24
    def build_error_callback; end

    # Add extra methods that we need
    #
    # @param mod [::Rdkafka::Bindings] rdkafka bindings module
    #
    # source://karafka-core//lib/karafka/core/patches/rdkafka/bindings.rb#15
    def included(mod); end
  end
end

# Namespace related to extension allowing to attach tags to any object.
# It can be used to assign tags in runtime to objects and use those tags in metrics, reporting
# and other places.
#
# Tags will be converted to strings when they are added
#
# source://karafka-core//lib/karafka/core/taggable.rb#10
module Karafka::Core::Taggable
  # @return [::Karafka::Core::Taggable::Tags] tags object
  #
  # source://karafka-core//lib/karafka/core/taggable.rb#12
  def tags; end
end

# This allows us to collect tags about given object. We attach name to each tag, because we
# may want to replace given tag with a different one and we need to have a reference of
# what we want to replace
#
# source://karafka-core//lib/karafka/core/taggable/tags.rb#9
class Karafka::Core::Taggable::Tags
  # Creates new tags accumulator
  #
  # @return [Tags] a new instance of Tags
  #
  # source://karafka-core//lib/karafka/core/taggable/tags.rb#11
  def initialize; end

  # Adds a tag with a given name to tags
  #
  # @param name [Symbol] name we want to use for a given tag
  # @param tag [#to_s] any object that can be converted into a string via `#to_s`
  #
  # source://karafka-core//lib/karafka/core/taggable/tags.rb#18
  def add(name, tag); end

  # @param _args [Object] anything that the standard `as_json` accepts
  # @return [Array<String>] array that can be converted to json
  #
  # source://karafka-core//lib/karafka/core/taggable/tags.rb#46
  def as_json(*_args); end

  # Removes all the tags
  #
  # source://karafka-core//lib/karafka/core/taggable/tags.rb#23
  def clear; end

  # Removes a tag with a given name
  #
  # @param name [Symbol] name of the tag
  #
  # source://karafka-core//lib/karafka/core/taggable/tags.rb#29
  def delete(name); end

  # @return [Array<String>] all unique tags registered
  #
  # source://karafka-core//lib/karafka/core/taggable/tags.rb#34
  def to_a; end

  # @param _args [Object] anything that the standard `to_json` accepts
  # @return [String] json representation of tags
  #
  # source://karafka-core//lib/karafka/core/taggable/tags.rb#40
  def to_json(*_args); end
end

# Current Karafka::Core version
# We follow the versioning schema of given Karafka version
#
# source://karafka-core//lib/karafka/core/version.rb#7
Karafka::Core::VERSION = T.let(T.unsafe(nil), String)

module Rdkafka::Bindings
  include ::Karafka::Core::Patches::Rdkafka::Bindings
end
