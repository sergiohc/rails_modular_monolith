# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `waterdrop` gem.
# Please instead update this file by running `bin/tapioca gem waterdrop`.


# WaterDrop library
#
# source://waterdrop//lib/waterdrop.rb#16
module WaterDrop
  class << self
    # @return [String] root path of this gem
    #
    # source://waterdrop//lib/waterdrop.rb#19
    def gem_root; end
  end
end

# Namespace for all the clients that WaterDrop may use under the hood
#
# source://waterdrop//lib/waterdrop.rb#0
module WaterDrop::Clients; end

# Client used to buffer messages that we send out in specs and other places.
#
# source://waterdrop//lib/waterdrop/clients/buffered.rb#6
class WaterDrop::Clients::Buffered < ::WaterDrop::Clients::Dummy
  # @param args [Object] anything accepted by `Clients::Dummy`
  # @return [Buffered] a new instance of Buffered
  #
  # source://waterdrop//lib/waterdrop/clients/buffered.rb#10
  def initialize(*args); end

  # Aborts the transaction
  #
  # source://waterdrop//lib/waterdrop/clients/buffered.rb#70
  def abort_transaction; end

  # Starts the transaction on a given level
  #
  # source://waterdrop//lib/waterdrop/clients/buffered.rb#38
  def begin_transaction; end

  # Finishes given level of transaction
  #
  # source://waterdrop//lib/waterdrop/clients/buffered.rb#44
  def commit_transaction; end

  # Returns the value of attribute messages.
  #
  # source://waterdrop//lib/waterdrop/clients/buffered.rb#7
  def messages; end

  # Sets the attribute messages
  #
  # @param value the value to set the attribute messages to.
  #
  # source://waterdrop//lib/waterdrop/clients/buffered.rb#7
  def messages=(_arg0); end

  # Returns messages produced to a given topic
  #
  # @param topic [String]
  #
  # source://waterdrop//lib/waterdrop/clients/buffered.rb#79
  def messages_for(topic); end

  # "Produces" message to Kafka: it acknowledges it locally, adds it to the internal buffer
  #
  # @param message [Hash] `WaterDrop::Producer#produce_sync` message hash
  # @return [Dummy::Handle] fake delivery handle that can be materialized into a report
  #
  # source://waterdrop//lib/waterdrop/clients/buffered.rb#24
  def produce(message); end

  # Clears internal buffer
  # Used in between specs so messages do not leak out
  #
  # source://waterdrop//lib/waterdrop/clients/buffered.rb#85
  def reset; end

  # Fakes storing the offset in a transactional fashion
  #
  # @param _consumer [#consumer_group_metadata_pointer] any consumer from which we can obtain
  #   the librdkafka consumer group metadata pointer
  # @param _tpl [Rdkafka::Consumer::TopicPartitionList] consumer tpl for offset storage
  # @param _timeout [Integer] ms timeout
  #
  # source://waterdrop//lib/waterdrop/clients/buffered.rb#65
  def send_offsets_to_transaction(_consumer, _tpl, _timeout); end
end

# A dummy client that is supposed to be used instead of Rdkafka::Producer in case we don't
# want to dispatch anything to Kafka.
#
# It does not store anything and just ignores messages. It does however return proper delivery
# handle that can be materialized into a report.
#
# source://waterdrop//lib/waterdrop/clients/dummy.rb#10
class WaterDrop::Clients::Dummy
  # @param _producer [WaterDrop::Producer]
  # @return [Dummy] dummy instance
  #
  # source://waterdrop//lib/waterdrop/clients/dummy.rb#44
  def initialize(_producer); end

  # @param _args [Object] anything really, this dummy is suppose to support anything
  # @return [self] returns self for chaining cases
  #
  # source://waterdrop//lib/waterdrop/clients/dummy.rb#64
  def method_missing(*_args); end

  # "Produces" the message
  #
  # @param topic [String, Symbol] topic where we want to dispatch message
  # @param partition [Integer] target partition
  # @param _args [Hash] remaining details that are ignored in the dummy mode
  # @return [Handle] delivery handle
  #
  # source://waterdrop//lib/waterdrop/clients/dummy.rb#53
  def produce(topic:, partition: T.unsafe(nil), **_args); end

  private

  # @param _args [Object] anything really, this dummy is suppose to support anything
  # @return [Boolean]
  #
  # source://waterdrop//lib/waterdrop/clients/dummy.rb#58
  def respond_to_missing?(*_args); end
end

# `::Rdkafka::Producer::DeliveryHandle` object API compatible dummy object
#
# source://waterdrop//lib/waterdrop/clients/dummy.rb#12
class WaterDrop::Clients::Dummy::Handle < ::Rdkafka::Producer::DeliveryHandle
  # @param topic [String] topic where we want to dispatch message
  # @param partition [Integer] target partition
  # @param offset [Integer] offset assigned by our fake "Kafka"
  # @return [Handle] a new instance of Handle
  #
  # source://waterdrop//lib/waterdrop/clients/dummy.rb#16
  def initialize(topic, partition, offset); end

  # Creates a delivery report with details where the message went
  #
  # @return [::Rdkafka::Producer::DeliveryReport]
  #
  # source://waterdrop//lib/waterdrop/clients/dummy.rb#33
  def create_result; end

  # Does not wait, just creates the result
  #
  # @param _args [Array] anything the wait handle would accept
  # @return [::Rdkafka::Producer::DeliveryReport]
  #
  # source://waterdrop//lib/waterdrop/clients/dummy.rb#26
  def wait(*_args); end
end

# Default Rdkafka client.
# Since we use the ::Rdkafka::Producer under the hood, this is just a module that aligns with
# client building API for the convenience.
#
# source://waterdrop//lib/waterdrop/clients/rdkafka.rb#9
module WaterDrop::Clients::Rdkafka
  class << self
    # @note We overwrite this that way, because we do not care
    # @param producer [WaterDrop::Producer] producer instance with its config, etc
    #
    # source://waterdrop//lib/waterdrop/clients/rdkafka.rb#13
    def new(producer); end
  end
end

# Configuration object for setting up all options required by WaterDrop
#
# source://waterdrop//lib/waterdrop/config.rb#7
class WaterDrop::Config
  include ::Karafka::Core::Configurable
  include ::Karafka::Core::Configurable::InstanceMethods
  extend ::Karafka::Core::Configurable
  extend ::Karafka::Core::Configurable::ClassMethods

  # Configuration method
  #
  # @yield Runs a block of code providing a config singleton instance to it
  # @yieldparam WaterDrop [WaterDrop::Config] config instance
  #
  # source://waterdrop//lib/waterdrop/config.rb#107
  def setup; end

  private

  # Propagates the kafka setting defaults unless they are already present
  # This makes it easier to set some values that users usually don't change but still allows them
  # to overwrite the whole hash if they want to
  #
  # @param config [Karafka::Core::Configurable::Node] config of this producer
  #
  # source://waterdrop//lib/waterdrop/config.rb#127
  def merge_kafka_defaults!(config); end
end

# Defaults for kafka settings, that will be overwritten only if not present already
#
# source://waterdrop//lib/waterdrop/config.rb#11
WaterDrop::Config::KAFKA_DEFAULTS = T.let(T.unsafe(nil), Hash)

# Namespace for all the contracts for config validations
#
# source://waterdrop//lib/waterdrop/contracts.rb#5
module WaterDrop::Contracts; end

# Contract with validation rules for WaterDrop configuration details
#
# source://waterdrop//lib/waterdrop/contracts/config.rb#6
class WaterDrop::Contracts::Config < ::Karafka::Core::Contractable::Contract; end

# Contract with validation rules for validating that all the message options that
# we provide to producer are valid and usable
#
# source://waterdrop//lib/waterdrop/contracts/message.rb#7
class WaterDrop::Contracts::Message < ::Karafka::Core::Contractable::Contract
  # @param max_payload_size [Integer] max payload size
  # @return [Message] a new instance of Message
  #
  # source://waterdrop//lib/waterdrop/contracts/message.rb#24
  def initialize(max_payload_size:); end

  # Returns the value of attribute max_payload_size.
  #
  # source://waterdrop//lib/waterdrop/contracts/message.rb#21
  def max_payload_size; end
end

# Regex to check that topic has a valid format
#
# source://waterdrop//lib/waterdrop/contracts/message.rb#17
WaterDrop::Contracts::Message::TOPIC_REGEXP = T.let(T.unsafe(nil), Regexp)

# Contract to ensure that arguments provided to the transactional offset commit are valid
# and match our expectations
#
# source://waterdrop//lib/waterdrop/contracts/transactional_offset.rb#7
class WaterDrop::Contracts::TransactionalOffset < ::Karafka::Core::Contractable::Contract; end

# Variant validator to ensure basic sanity of the variant alteration data
#
# source://waterdrop//lib/waterdrop/contracts/variant.rb#6
class WaterDrop::Contracts::Variant < ::Karafka::Core::Contractable::Contract; end

# Boolean values
#
# source://waterdrop//lib/waterdrop/contracts/variant.rb#25
WaterDrop::Contracts::Variant::BOOLEANS = T.let(T.unsafe(nil), Array)

# Taken from librdkafka config
# Those values can be changed on a per topic basis. We do not support experimental or
# deprecated values. We also do not support settings that would break rdkafka-ruby
#
# @see https://karafka.io/docs/Librdkafka-Configuration/#topic-configuration-properties
#
# source://waterdrop//lib/waterdrop/contracts/variant.rb#12
WaterDrop::Contracts::Variant::TOPIC_CONFIG_KEYS = T.let(T.unsafe(nil), Array)

# Namespace used to encapsulate all the internal errors of WaterDrop
#
# source://waterdrop//lib/waterdrop/errors.rb#5
module WaterDrop::Errors; end

# Raise it within a transaction to abort it
# It does not have an `Error` postfix because technically it is not an error as it is used for
# graceful transaction aborting
#
# source://waterdrop//lib/waterdrop/errors.rb#48
class WaterDrop::Errors::AbortTransaction < ::WaterDrop::Errors::BaseError; end

# Base class for all the WaterDrop internal errors
#
# source://waterdrop//lib/waterdrop/errors.rb#7
class WaterDrop::Errors::BaseError < ::StandardError; end

# Raised when configuration doesn't match with validation contract
#
# source://waterdrop//lib/waterdrop/errors.rb#10
class WaterDrop::Errors::ConfigurationInvalidError < ::WaterDrop::Errors::BaseError; end

# Raised when we want to send a message that is invalid (impossible topic, etc)
#
# source://waterdrop//lib/waterdrop/errors.rb#29
class WaterDrop::Errors::MessageInvalidError < ::WaterDrop::Errors::BaseError; end

# Raised when there is an inline error during single message produce operations
#
# source://waterdrop//lib/waterdrop/errors.rb#39
class WaterDrop::Errors::ProduceError < ::WaterDrop::Errors::BaseError; end

# Raised when during messages producing something bad happened inline
#
# source://waterdrop//lib/waterdrop/errors.rb#51
class WaterDrop::Errors::ProduceManyError < ::WaterDrop::Errors::ProduceError
  # @param dispatched [Array<Rdkafka::Producer::DeliveryHandle>] handlers of the
  #   messages that we've dispatched
  # @param message [String] error message
  # @return [ProduceManyError] a new instance of ProduceManyError
  #
  # source://waterdrop//lib/waterdrop/errors.rb#57
  def initialize(dispatched, message); end

  # Returns the value of attribute dispatched.
  #
  # source://waterdrop//lib/waterdrop/errors.rb#52
  def dispatched; end
end

# Raised when we want to reconfigure a producer that was already configured
#
# source://waterdrop//lib/waterdrop/errors.rb#19
class WaterDrop::Errors::ProducerAlreadyConfiguredError < ::WaterDrop::Errors::BaseError; end

# Raised when there was an attempt to use a closed producer
#
# source://waterdrop//lib/waterdrop/errors.rb#26
class WaterDrop::Errors::ProducerClosedError < ::WaterDrop::Errors::BaseError; end

# Raised when we want to use a producer that was not configured
#
# source://waterdrop//lib/waterdrop/errors.rb#16
class WaterDrop::Errors::ProducerNotConfiguredError < ::WaterDrop::Errors::BaseError; end

# Raised when trying to use connected producer from a forked child process
# Producers cannot be used in forks if they were already used in the child processes
#
# source://waterdrop//lib/waterdrop/errors.rb#23
class WaterDrop::Errors::ProducerUsedInParentProcess < ::WaterDrop::Errors::BaseError; end

# Raised when we've got an unexpected status. This should never happen. If it does, please
# contact us as it is an error.
#
# source://waterdrop//lib/waterdrop/errors.rb#36
class WaterDrop::Errors::StatusInvalidError < ::WaterDrop::Errors::BaseError; end

# Raised when we attempt to perform operation that is only allowed inside of a transaction and
# there is no transaction around us
#
# source://waterdrop//lib/waterdrop/errors.rb#43
class WaterDrop::Errors::TransactionRequiredError < ::WaterDrop::Errors::BaseError; end

# Raised when we want to commit transactional offset and the input is invalid
#
# source://waterdrop//lib/waterdrop/errors.rb#32
class WaterDrop::Errors::TransactionalOffsetInvalidError < ::WaterDrop::Errors::BaseError; end

# Raised when variant alteration is not valid
#
# source://waterdrop//lib/waterdrop/errors.rb#13
class WaterDrop::Errors::VariantInvalidError < ::WaterDrop::Errors::BaseError; end

# Extra internal helper objects
#
# source://waterdrop//lib/waterdrop.rb#0
module WaterDrop::Helpers; end

# Atomic counter that we can safely increment and decrement without race conditions
#
# source://waterdrop//lib/waterdrop/helpers/counter.rb#7
class WaterDrop::Helpers::Counter
  # @return [Counter] a new instance of Counter
  #
  # source://waterdrop//lib/waterdrop/helpers/counter.rb#11
  def initialize; end

  # Decrements the value by 1
  #
  # source://waterdrop//lib/waterdrop/helpers/counter.rb#22
  def decrement; end

  # Increments the value by 1
  #
  # source://waterdrop//lib/waterdrop/helpers/counter.rb#17
  def increment; end

  # @return [Integer] current value
  #
  # source://waterdrop//lib/waterdrop/helpers/counter.rb#9
  def value; end
end

# WaterDrop instrumentation related module
#
# source://waterdrop//lib/waterdrop/config.rb#0
module WaterDrop::Instrumentation; end

# Namespace for handlers of callbacks emitted by the kafka client lib
#
# source://waterdrop//lib/waterdrop.rb#0
module WaterDrop::Instrumentation::Callbacks; end

# Creates a callable that we want to run upon each message delivery or failure
#
# @note We don't have to provide client_name here as this callback is per client instance
# @note We do not consider `message.purge` as an error for transactional producers, because
#   this is a standard behaviour for not yet dispatched messages on aborted transactions.
#   We do however still want to instrument it for traceability.
#
# source://waterdrop//lib/waterdrop/instrumentation/callbacks/delivery.rb#13
class WaterDrop::Instrumentation::Callbacks::Delivery
  # @param producer_id [String] id of the current producer
  # @param transactional [Boolean] is this handle for a transactional or regular producer
  # @param monitor [WaterDrop::Instrumentation::Monitor] monitor we are using
  # @return [Delivery] a new instance of Delivery
  #
  # source://waterdrop//lib/waterdrop/instrumentation/callbacks/delivery.rb#28
  def initialize(producer_id, transactional, monitor); end

  # Emits delivery details to the monitor
  #
  # @param delivery_report [Rdkafka::Producer::DeliveryReport] delivery report
  #
  # source://waterdrop//lib/waterdrop/instrumentation/callbacks/delivery.rb#36
  def call(delivery_report); end

  private

  # Builds appropriate rdkafka error
  #
  # @param delivery_report [Rdkafka::Producer::DeliveryReport] delivery report
  # @return [::Rdkafka::RdkafkaError]
  #
  # source://waterdrop//lib/waterdrop/instrumentation/callbacks/delivery.rb#111
  def build_error(delivery_report); end

  # @param delivery_report [Rdkafka::Producer::DeliveryReport] delivery report
  #
  # source://waterdrop//lib/waterdrop/instrumentation/callbacks/delivery.rb#63
  def instrument_acknowledged(delivery_report); end

  # @param delivery_report [Rdkafka::Producer::DeliveryReport] delivery report
  #
  # source://waterdrop//lib/waterdrop/instrumentation/callbacks/delivery.rb#93
  def instrument_error(delivery_report); end

  # @param delivery_report [Rdkafka::Producer::DeliveryReport] delivery report
  #
  # source://waterdrop//lib/waterdrop/instrumentation/callbacks/delivery.rb#77
  def instrument_purged(delivery_report); end
end

# Errors related to queue purging that is expected in transactions
#
# source://waterdrop//lib/waterdrop/instrumentation/callbacks/delivery.rb#21
WaterDrop::Instrumentation::Callbacks::Delivery::PURGE_ERRORS = T.let(T.unsafe(nil), Array)

# Error emitted when a message was purged while it was dispatched
#
# source://waterdrop//lib/waterdrop/instrumentation/callbacks/delivery.rb#18
WaterDrop::Instrumentation::Callbacks::Delivery::RD_KAFKA_RESP_PURGE_INFLIGHT = T.let(T.unsafe(nil), Integer)

# Error emitted when a message was not yet dispatched and was purged from the queue
#
# source://waterdrop//lib/waterdrop/instrumentation/callbacks/delivery.rb#15
WaterDrop::Instrumentation::Callbacks::Delivery::RD_KAFKA_RESP_PURGE_QUEUE = T.let(T.unsafe(nil), Integer)

# Callback that kicks in when error occurs and is published in a background thread
#
# source://waterdrop//lib/waterdrop/instrumentation/callbacks/error.rb#7
class WaterDrop::Instrumentation::Callbacks::Error
  # @param producer_id [String] id of the current producer
  # @param client_name [String] rdkafka client name
  # @param monitor [WaterDrop::Instrumentation::Monitor] monitor we are using
  # @return [Error] a new instance of Error
  #
  # source://waterdrop//lib/waterdrop/instrumentation/callbacks/error.rb#11
  def initialize(producer_id, client_name, monitor); end

  # Runs the instrumentation monitor with error
  #
  # @note It will only instrument on errors of the client of our producer
  # @note When there is a particular message produce error (not internal error), the error
  #   is shipped via the delivery callback, not via error callback.
  # @param client_name [String] rdkafka client name
  # @param error [Rdkafka::Error] error that occurred
  #
  # source://waterdrop//lib/waterdrop/instrumentation/callbacks/error.rb#23
  def call(client_name, error); end
end

# Callback that is triggered when oauth token needs to be refreshed.
#
# source://waterdrop//lib/waterdrop/instrumentation/callbacks/oauthbearer_token_refresh.rb#7
class WaterDrop::Instrumentation::Callbacks::OauthbearerTokenRefresh
  # @param bearer [Rdkafka::Producer] given rdkafka instance. It is needed as
  #   we need to have a reference to call `#oauthbearer_set_token` or
  #   `#oauthbearer_set_token_failure` upon the event.
  # @param monitor [WaterDrop::Instrumentation::Monitor] monitor we are using
  # @return [OauthbearerTokenRefresh] a new instance of OauthbearerTokenRefresh
  #
  # source://waterdrop//lib/waterdrop/instrumentation/callbacks/oauthbearer_token_refresh.rb#12
  def initialize(bearer, monitor); end

  # Upon receiving of this event, user is required to invoke either `#oauthbearer_set_token`
  # or `#oauthbearer_set_token_failure` on the `event[:bearer]` depending whether token
  # obtaining was successful or not.
  #
  # Please refer to WaterDrop and Karafka documentation or `Rdkafka::Helpers::OAuth`
  # documentation directly for exact parameters of those methods.
  #
  # @param _rd_config [Rdkafka::Config]
  # @param bearer_name [String] name of the bearer for which we refresh
  #
  # source://waterdrop//lib/waterdrop/instrumentation/callbacks/oauthbearer_token_refresh.rb#26
  def call(_rd_config, bearer_name); end
end

# Statistics callback handler
#
# @note We decorate the statistics with our own decorator because some of the metrics from
#   rdkafka are absolute. For example number of sent messages increases not in reference to
#   previous statistics emit but from the beginning of the process. We decorate it with diff
#   of all the numeric values against the data from the previous callback emit
#
# source://waterdrop//lib/waterdrop/instrumentation/callbacks/statistics.rb#12
class WaterDrop::Instrumentation::Callbacks::Statistics
  # @param producer_id [String] id of the current producer
  # @param client_name [String] rdkafka client name
  # @param monitor [WaterDrop::Instrumentation::Monitor] monitor we are using
  # @return [Statistics] a new instance of Statistics
  #
  # source://waterdrop//lib/waterdrop/instrumentation/callbacks/statistics.rb#16
  def initialize(producer_id, client_name, monitor); end

  # Emits decorated statistics to the monitor
  #
  # @param statistics [Hash] rdkafka statistics
  #
  # source://waterdrop//lib/waterdrop/instrumentation/callbacks/statistics.rb#25
  def call(statistics); end
end

# Default listener that hooks up to our instrumentation and uses its events for logging
# It can be removed/replaced or anything without any harm to the Waterdrop flow
#
# @note It is a module as we can use it then as a part of the Karafka framework listener
#   as well as we can use it standalone
#
# source://waterdrop//lib/waterdrop/instrumentation/logger_listener.rb#10
class WaterDrop::Instrumentation::LoggerListener
  # @param logger [Object] logger we want to use
  # @param log_messages [Boolean] Should we report the messages content (payload and metadata)
  #   with each message operation.
  #
  #   This can be extensive, especially when producing a lot of messages. We provide this
  #   despite the fact that we only report payloads in debug, because Rails by default operates
  #   with debug level. This means, that when working with Rails in development, every single
  #   payload dispatched will go to logs. In majority of the cases this is extensive and simply
  #   floods the end user.
  # @return [LoggerListener] a new instance of LoggerListener
  #
  # source://waterdrop//lib/waterdrop/instrumentation/logger_listener.rb#20
  def initialize(logger, log_messages: T.unsafe(nil)); end

  # @param event [Dry::Events::Event] event that happened with the details
  #
  # source://waterdrop//lib/waterdrop/instrumentation/logger_listener.rb#94
  def on_buffer_flushed_async(event); end

  # @param event [Dry::Events::Event] event that happened with the details
  #
  # source://waterdrop//lib/waterdrop/instrumentation/logger_listener.rb#105
  def on_buffer_flushed_sync(event); end

  # @param event [Dry::Events::Event] event that happened with the details
  #
  # source://waterdrop//lib/waterdrop/instrumentation/logger_listener.rb#116
  def on_buffer_purged(event); end

  # @param event [Dry::Events::Event] event that happened with the error details
  #
  # source://waterdrop//lib/waterdrop/instrumentation/logger_listener.rb#138
  def on_error_occurred(event); end

  # @param event [Dry::Events::Event] event that happened with the details
  #
  # source://waterdrop//lib/waterdrop/instrumentation/logger_listener.rb#72
  def on_message_buffered(event); end

  # @param event [Dry::Events::Event] event that happened with the details
  #
  # source://waterdrop//lib/waterdrop/instrumentation/logger_listener.rb#26
  def on_message_produced_async(event); end

  # @param event [Dry::Events::Event] event that happened with the details
  #
  # source://waterdrop//lib/waterdrop/instrumentation/logger_listener.rb#37
  def on_message_produced_sync(event); end

  # @param event [Dry::Events::Event] event that happened with the details
  #
  # source://waterdrop//lib/waterdrop/instrumentation/logger_listener.rb#83
  def on_messages_buffered(event); end

  # @param event [Dry::Events::Event] event that happened with the details
  #
  # source://waterdrop//lib/waterdrop/instrumentation/logger_listener.rb#48
  def on_messages_produced_async(event); end

  # @param event [Dry::Events::Event] event that happened with the details
  #
  # source://waterdrop//lib/waterdrop/instrumentation/logger_listener.rb#60
  def on_messages_produced_sync(event); end

  # @note While this says "Closing producer", it produces a nice message with time taken:
  #   "Closing producer took 12 ms" indicating it happened in the past.
  # @param event [Dry::Events::Event] event that happened with the details
  #
  # source://waterdrop//lib/waterdrop/instrumentation/logger_listener.rb#128
  def on_producer_closed(event); end

  # @param event [Dry::Events::Event] event that happened with the details
  #
  # source://waterdrop//lib/waterdrop/instrumentation/logger_listener.rb#121
  def on_producer_closing(event); end

  # @param event [Dry::Events::Event] event that happened with the details
  #
  # source://waterdrop//lib/waterdrop/instrumentation/logger_listener.rb#133
  def on_producer_reloaded(event); end

  # @param event [Dry::Events::Event] event that happened with the details
  #
  # source://waterdrop//lib/waterdrop/instrumentation/logger_listener.rb#151
  def on_transaction_aborted(event); end

  # @param event [Dry::Events::Event] event that happened with the details
  #
  # source://waterdrop//lib/waterdrop/instrumentation/logger_listener.rb#156
  def on_transaction_committed(event); end

  # @param event [Dry::Events::Event] event that happened with the details
  #
  # source://waterdrop//lib/waterdrop/instrumentation/logger_listener.rb#175
  def on_transaction_finished(event); end

  # @param event [Dry::Events::Event] event that happened with the details
  #
  # source://waterdrop//lib/waterdrop/instrumentation/logger_listener.rb#161
  def on_transaction_marked_as_consumed(event); end

  # @param event [Dry::Events::Event] event that happened with the details
  #
  # source://waterdrop//lib/waterdrop/instrumentation/logger_listener.rb#146
  def on_transaction_started(event); end

  private

  # @param event [Dry::Events::Event] event that happened with the details
  # @param log_message [String] message we want to publish
  #
  # source://waterdrop//lib/waterdrop/instrumentation/logger_listener.rb#188
  def debug(event, log_message); end

  # @param event [Dry::Events::Event] event that happened with the details
  # @param log_message [String] message we want to publish
  #
  # source://waterdrop//lib/waterdrop/instrumentation/logger_listener.rb#204
  def error(event, log_message); end

  # @param event [Dry::Events::Event] event that happened with the details
  # @param log_message [String] message we want to publish
  #
  # source://waterdrop//lib/waterdrop/instrumentation/logger_listener.rb#194
  def info(event, log_message); end

  # @return [Boolean] should we report the messages details in the debug mode.
  #
  # source://waterdrop//lib/waterdrop/instrumentation/logger_listener.rb#182
  def log_messages?; end
end

# WaterDrop instrumentation monitor that we use to publish events
# By default uses our internal notifications bus but can be used with
# `ActiveSupport::Notifications` as well
#
# source://waterdrop//lib/waterdrop/instrumentation/monitor.rb#8
class WaterDrop::Instrumentation::Monitor < ::Karafka::Core::Monitoring::Monitor
  # @param notifications_bus [Object] either our internal notifications bus or
  #   `ActiveSupport::Notifications`
  # @param namespace [String, nil] namespace for events or nil if no namespace
  # @return [Monitor] a new instance of Monitor
  #
  # source://waterdrop//lib/waterdrop/instrumentation/monitor.rb#12
  def initialize(notifications_bus = T.unsafe(nil), namespace = T.unsafe(nil)); end
end

# Instrumented is used to hookup external monitoring services to monitor how WaterDrop works
#
# source://waterdrop//lib/waterdrop/instrumentation/notifications.rb#6
class WaterDrop::Instrumentation::Notifications < ::Karafka::Core::Monitoring::Notifications
  # @return [WaterDrop::Instrumentation::Monitor] monitor instance for system instrumentation
  #
  # source://waterdrop//lib/waterdrop/instrumentation/notifications.rb#43
  def initialize; end
end

# List of events that we support in the system and to which a monitor client can hook up
#
# @note The non-error once support timestamp benchmarking
#
# source://waterdrop//lib/waterdrop/instrumentation/notifications.rb#9
WaterDrop::Instrumentation::Notifications::EVENTS = T.let(T.unsafe(nil), Array)

# Simple middleware layer for manipulating messages prior to their validation
#
# source://waterdrop//lib/waterdrop/middleware.rb#5
class WaterDrop::Middleware
  # @return [Middleware] a new instance of Middleware
  #
  # source://waterdrop//lib/waterdrop/middleware.rb#6
  def initialize; end

  # Register given middleware as the last one in the chain
  #
  # @param step [#call] step that needs to return the message
  #
  # source://waterdrop//lib/waterdrop/middleware.rb#44
  def append(step); end

  # Register given middleware as the first one in the chain
  #
  # @param step [#call] step that needs to return the message
  #
  # source://waterdrop//lib/waterdrop/middleware.rb#36
  def prepend(step); end

  # Runs middleware on a single message prior to validation
  #
  # @note You need to decide yourself whether you don't use the message hash data anywhere else
  #   and you want to save on memory by modifying it in place or do you want to do a deep copy
  # @param message [Hash] message hash
  # @return [Hash] message hash. Either the same if transformed in place, or a copy if modified
  #   into a new object.
  #
  # source://waterdrop//lib/waterdrop/middleware.rb#18
  def run(message); end

  # @param messages [Array<Hash>] messages on which we want to run middlewares
  # @return [Array<Hash>] transformed messages
  #
  # source://waterdrop//lib/waterdrop/middleware.rb#28
  def run_many(messages); end
end

# Main WaterDrop messages producer
#
# source://waterdrop//lib/waterdrop/producer.rb#5
class WaterDrop::Producer
  include ::WaterDrop::Producer::Sync
  include ::WaterDrop::Producer::Async
  include ::WaterDrop::Producer::Buffer
  include ::WaterDrop::Producer::Transactions
  include ::Karafka::Core::Helpers::Time
  extend ::Forwardable

  # Creates a not-yet-configured instance of the producer
  #
  # @param block [Proc] configuration block
  # @return [Producer] producer instance
  #
  # source://waterdrop//lib/waterdrop/producer.rb#40
  def initialize(&block); end

  # @note Client is lazy initialized, keeping in mind also the fact of a potential fork that
  #   can happen any time.
  # @note It is not recommended to fork a producer that is already in use so in case of
  #   bootstrapping a cluster, it's much better to fork configured but not used producers
  # @raise [Errors::ProducerNotConfiguredError]
  # @return [Rdkafka::Producer] raw rdkafka producer
  #
  # source://waterdrop//lib/waterdrop/producer.rb#77
  def client; end

  # Flushes the buffers in a sync way and closes the producer
  #
  # @param force [Boolean] should we force closing even with outstanding messages after the
  #   max wait timeout
  #
  # source://waterdrop//lib/waterdrop/producer.rb#176
  def close(force: T.unsafe(nil)); end

  # Closes the producer with forced close after timeout, purging any outgoing data
  #
  # source://waterdrop//lib/waterdrop/producer.rb#241
  def close!; end

  # @return [Object] dry-configurable config object
  #
  # source://waterdrop//lib/waterdrop/producer.rb#35
  def config; end

  # @return [String] uuid of the current producer
  #
  # source://waterdrop//lib/waterdrop/producer.rb#27
  def id; end

  # @return [Boolean] true if current producer is idempotent
  #
  # source://waterdrop//lib/waterdrop/producer.rb#159
  def idempotent?; end

  # @return [Array] internal messages buffer
  #
  # source://waterdrop//lib/waterdrop/producer.rb#31
  def messages; end

  # Returns and caches the middleware object that may be used
  #
  # @return [WaterDrop::Producer::Middleware]
  #
  # source://waterdrop//lib/waterdrop/producer.rb#169
  def middleware; end

  # @return [Object] monitor we want to use
  #
  # source://waterdrop//lib/waterdrop/producer.rb#33
  def monitor; end

  # Fetches and caches the partition count of a topic
  #
  # @note It uses the underlying `rdkafka-ruby` partition count fetch and cache.
  # @param topic [String] topic for which we want to get the number of partitions
  # @return [Integer] number of partitions of the requested topic or -1 if number could not be
  #   retrieved.
  #
  # source://waterdrop//lib/waterdrop/producer.rb#122
  def partition_count(topic); end

  # Purges data from both the buffer queue as well as the librdkafka queue.
  #
  # @note This is an operation that can cause data loss. Keep that in mind. It will not only
  #   purge the internal WaterDrop buffer but will also purge the librdkafka queue as well as
  #   will cancel any outgoing messages dispatches.
  #
  # source://waterdrop//lib/waterdrop/producer.rb#131
  def purge; end

  # Sets up the whole configuration and initializes all that is needed
  #
  # @param block [Block] configuration block
  # @raise [Errors::ProducerAlreadyConfiguredError]
  #
  # source://waterdrop//lib/waterdrop/producer.rb#57
  def setup(&block); end

  # @return [Status] producer status object
  #
  # source://waterdrop//lib/waterdrop/producer.rb#29
  def status; end

  # Builds the variant alteration and returns it.
  #
  # @param args [Object] anything `Producer::Variant` initializer accepts
  # @return [WaterDrop::Producer::Variant] variant proxy to use with alterations
  #
  # source://waterdrop//lib/waterdrop/producer.rb#150
  def variant(**args); end

  # Builds the variant alteration and returns it.
  #
  # @param args [Object] anything `Producer::Variant` initializer accepts
  # @return [WaterDrop::Producer::Variant] variant proxy to use with alterations
  #
  # source://waterdrop//lib/waterdrop/producer.rb#150
  def with(**args); end

  private

  # @return [Producer::Context] the variant config. Either custom if built using `#with` or
  #   a default one.
  #
  # source://waterdrop//lib/waterdrop/producer.rb#281
  def current_variant; end

  # Ensures that we don't run any operations when the producer is not configured or when it
  # was already closed
  #
  # @raise [Errors::ProducerNotConfiguredError]
  #
  # source://waterdrop//lib/waterdrop/producer.rb#249
  def ensure_active!; end

  # Runs the client produce method with a given message
  #
  # @param message [Hash] message we want to send
  #
  # source://waterdrop//lib/waterdrop/producer.rb#288
  def produce(message); end

  # Ensures that the message we want to send out to Kafka is actually valid and that it can be
  # sent there
  #
  # @param message [Hash] message we want to send
  # @raise [Karafka::Errors::MessageInvalidError]
  #
  # source://waterdrop//lib/waterdrop/producer.rb#265
  def validate_message!(message); end

  # Waits on a given handler
  #
  # @param handler [Rdkafka::Producer::DeliveryHandle]
  #
  # source://waterdrop//lib/waterdrop/producer.rb#272
  def wait(handler); end
end

# Component for asynchronous producer operations
#
# source://waterdrop//lib/waterdrop/producer/async.rb#6
module WaterDrop::Producer::Async
  # Produces a message to Kafka and does not wait for results
  #
  # @param message [Hash] hash that complies with the {Contracts::Message} contract
  # @raise [Rdkafka::RdkafkaError] When adding the message to rdkafka's queue failed
  # @raise [Errors::MessageInvalidError] When provided message details are invalid and the
  #   message could not be sent to Kafka
  # @return [Rdkafka::Producer::DeliveryHandle] delivery handle that might return the report
  #
  # source://waterdrop//lib/waterdrop/producer/async.rb#16
  def produce_async(message); end

  # Produces many messages to Kafka and does not wait for them to be delivered
  #
  # @param messages [Array<Hash>] array with messages that comply with the
  #   {Contracts::Message} contract
  # @raise [Rdkafka::RdkafkaError] When adding the messages to rdkafka's queue failed
  # @raise [Errors::MessageInvalidError] When any of the provided messages details are invalid
  #   and the message could not be sent to Kafka
  # @return [Array<Rdkafka::Producer::DeliveryHandle>] deliveries handles
  #
  # source://waterdrop//lib/waterdrop/producer/async.rb#53
  def produce_many_async(messages); end
end

# Component for buffered operations
#
# source://waterdrop//lib/waterdrop/producer/buffer.rb#6
module WaterDrop::Producer::Buffer
  # Adds given message into the internal producer buffer without flushing it to Kafka
  #
  # @param message [Hash] hash that complies with the {Contracts::Message} contract
  # @raise [Errors::MessageInvalidError] When provided message details are invalid and the
  #   message could not be sent to Kafka
  #
  # source://waterdrop//lib/waterdrop/producer/buffer.rb#12
  def buffer(message); end

  # Adds given messages into the internal producer buffer without flushing them to Kafka
  #
  # @param messages [Array<Hash>] array with messages that comply with the
  #   {Contracts::Message} contract
  # @raise [Errors::MessageInvalidError] When any of the provided messages details are invalid
  #   and the message could not be sent to Kafka
  #
  # source://waterdrop//lib/waterdrop/producer/buffer.rb#29
  def buffer_many(messages); end

  # Flushes the internal buffer to Kafka in an async way
  #
  # @return [Array<Rdkafka::Producer::DeliveryHandle>] delivery handles for messages that were
  #   flushed
  #
  # source://waterdrop//lib/waterdrop/producer/buffer.rb#46
  def flush_async; end

  # Flushes the internal buffer to Kafka in a sync way
  #
  # @return [Array<Rdkafka::Producer::DeliveryReport>] delivery reports for messages that were
  #   flushed
  #
  # source://waterdrop//lib/waterdrop/producer/buffer.rb#57
  def flush_sync; end

  private

  # Method for triggering the buffer
  #
  # @note We use this method underneath to provide a different instrumentation for sync and
  #   async flushing within the public API
  # @param sync [Boolean] should it flush in a sync way
  # @raise [Errors::ProduceManyError] when there was a failure in flushing
  # @return [Array<Rdkafka::Producer::DeliveryHandle, Rdkafka::Producer::DeliveryReport>] delivery handles for async or delivery reports for sync
  #
  # source://waterdrop//lib/waterdrop/producer/buffer.rb#74
  def flush(sync); end
end

# Class used to construct the rdkafka producer client
#
# source://waterdrop//lib/waterdrop/producer/builder.rb#6
class WaterDrop::Producer::Builder
  # @param producer [Producer] not yet configured producer for which we want to
  #   build the client
  # @param config [Object] dry-configurable based configuration object
  # @return [Rdkafka::Producer, Producer::DummyClient] raw rdkafka producer or a dummy producer
  #   when we don't want to dispatch any messages
  #
  # source://waterdrop//lib/waterdrop/producer/builder.rb#12
  def call(producer, config); end
end

# Empty has to save on memory allocations
#
# source://waterdrop//lib/waterdrop/producer.rb#20
WaterDrop::Producer::EMPTY_HASH = T.let(T.unsafe(nil), Hash)

# Which of the inline flow errors do we want to intercept and re-bind
#
# source://waterdrop//lib/waterdrop/producer.rb#14
WaterDrop::Producer::SUPPORTED_FLOW_ERRORS = T.let(T.unsafe(nil), Array)

# Producer lifecycle status object representation
#
# source://waterdrop//lib/waterdrop/producer/status.rb#6
class WaterDrop::Producer::Status
  # Creates a new instance of status with the initial state
  #
  # @return [Status]
  #
  # source://waterdrop//lib/waterdrop/producer/status.rb#20
  def initialize; end

  # @return [Boolean] true if producer is in a active state. Active means, that we can start
  #   sending messages. Actives states are connected (connection established) or configured,
  #   which means, that producer is configured, but connection with Kafka is
  #   not yet established.
  #
  # source://waterdrop//lib/waterdrop/producer/status.rb#28
  def active?; end

  # source://waterdrop//lib/waterdrop/producer/status.rb#45
  def closed!; end

  # source://waterdrop//lib/waterdrop/producer/status.rb#40
  def closed?; end

  # source://waterdrop//lib/waterdrop/producer/status.rb#45
  def closing!; end

  # source://waterdrop//lib/waterdrop/producer/status.rb#40
  def closing?; end

  # source://waterdrop//lib/waterdrop/producer/status.rb#45
  def configured!; end

  # source://waterdrop//lib/waterdrop/producer/status.rb#40
  def configured?; end

  # source://waterdrop//lib/waterdrop/producer/status.rb#45
  def connected!; end

  # source://waterdrop//lib/waterdrop/producer/status.rb#40
  def connected?; end

  # source://waterdrop//lib/waterdrop/producer/status.rb#45
  def initial!; end

  # source://waterdrop//lib/waterdrop/producer/status.rb#40
  def initial?; end

  # @return [String] current status as a string
  #
  # source://waterdrop//lib/waterdrop/producer/status.rb#33
  def to_s; end
end

# States in which the producer can be
#
# source://waterdrop//lib/waterdrop/producer/status.rb#8
WaterDrop::Producer::Status::LIFECYCLE = T.let(T.unsafe(nil), Array)

# Component for synchronous producer operations
#
# source://waterdrop//lib/waterdrop/producer/sync.rb#6
module WaterDrop::Producer::Sync
  # Produces many messages to Kafka and waits for them to be delivered
  #
  # @param messages [Array<Hash>] array with messages that comply with the
  #   {Contracts::Message} contract
  # @raise [Rdkafka::RdkafkaError] When adding the messages to rdkafka's queue failed
  # @raise [Rdkafka::Producer::WaitTimeoutError] When the timeout has been reached and some
  #   handles are still pending
  # @raise [Errors::MessageInvalidError] When any of the provided messages details are invalid
  #   and the message could not be sent to Kafka
  # @return [Array<Rdkafka::Producer::DeliveryReport>] delivery reports
  #
  # source://waterdrop//lib/waterdrop/producer/sync.rb#59
  def produce_many_sync(messages); end

  # Produces a message to Kafka and waits for it to be delivered
  #
  # @param message [Hash] hash that complies with the {Contracts::Message} contract
  # @raise [Rdkafka::RdkafkaError] When adding the message to rdkafka's queue failed
  # @raise [Rdkafka::Producer::WaitTimeoutError] When the timeout has been reached and the
  #   handle is still pending
  # @raise [Errors::MessageInvalidError] When provided message details are invalid and the
  #   message could not be sent to Kafka
  # @return [Rdkafka::Producer::DeliveryReport] delivery report
  #
  # source://waterdrop//lib/waterdrop/producer/sync.rb#18
  def produce_sync(message); end
end

# Transactions related producer functionalities
#
# source://waterdrop//lib/waterdrop/producer/transactions.rb#6
module WaterDrop::Producer::Transactions
  # Creates a transaction.
  #
  # Karafka transactions work in a similar manner to SQL db transactions though there are some
  # crucial differences. When you start a transaction, all messages produced during it will
  # be delivered together or will fail together. The difference is, that messages from within
  # a single transaction can be delivered and will have a delivery handle but will be then
  # compacted prior to moving the LSO forward. This means, that not every delivery handle for
  # async dispatches will emit a queue purge error. None for sync as the delivery has happened
  # but they will never be visible by the transactional consumers.
  #
  # Transactions **are** thread-safe however they lock a mutex. This means, that for
  # high-throughput transactional messages production in multiple threads
  # (for example in Karafka), it may be much better to use few instances that can work in
  # parallel.
  #
  # Please note, that if a producer is configured as transactional, it **cannot** produce
  # messages outside of transactions, that is why by default all dispatches will be wrapped
  # with a transaction. One transaction per single dispatch and for `produce_many` it will be
  # a single transaction wrapping all messages dispatches (not one per message).
  #
  # @example Simple transaction
  #   producer.transaction do
  #   producer.produce_async(topic: 'topic', payload: 'data')
  #   end
  # @example Aborted transaction - messages producer won't be visible by consumers
  #   producer.transaction do
  #   producer.produce_sync(topic: 'topic', payload: 'data')
  #   throw(:abort)
  #   end
  # @example Use block result last handler to wait on all messages ack
  #   handler = producer.transaction do
  #   producer.produce_async(topic: 'topic', payload: 'data')
  #   end
  #
  #   handler.wait
  # @return Block result
  #
  # source://waterdrop//lib/waterdrop/producer/transactions.rb#57
  def transaction; end

  # @return [Boolean] true if we are in an active transaction
  #
  # source://waterdrop//lib/waterdrop/producer/transactions.rb#115
  def transaction?; end

  # Marks given message as consumed inside of a transaction.
  #
  # @param consumer [#consumer_group_metadata_pointer] any consumer from which we can obtain
  #   the librdkafka consumer group metadata pointer
  # @param message [Karafka::Messages::Message] karafka message
  # @param offset_metadata [String] offset metadata or nil if none
  # @raise [Errors::TransactionRequiredError]
  #
  # source://waterdrop//lib/waterdrop/producer/transactions.rb#132
  def transaction_mark_as_consumed(consumer, message, offset_metadata = T.unsafe(nil)); end

  # @return [Boolean] Is this producer a transactional one
  #
  # source://waterdrop//lib/waterdrop/producer/transactions.rb#120
  def transactional?; end

  private

  # Instruments the transactional operation with producer id
  #
  # @param key [Symbol] transaction operation key
  # @param details [Hash] additional instrumentation details
  # @param block [Proc] block to run inside the instrumentation or nothing if not given
  #
  # source://waterdrop//lib/waterdrop/producer/transactions.rb#184
  def transactional_instrument(key, details = T.unsafe(nil), &block); end

  # Reloads the underlying client instance if needed and allowed
  #
  # This should be used only in transactions as only then we can get fatal transactional
  # errors and we can safely reload the client.
  #
  # Because we reload on any errors where cause is `Rdkafka::RdkafkaError` (minus exclusions)
  # this in theory can cause reload if it was something else that raised those in transactions,
  # for example Karafka. This is a trade-off. Since any error anyhow will cause a rollback,
  # putting aside performance implication of closing and reconnecting, this should not be an
  # issue.
  #
  # @note We only reload on rdkafka errors that are a cause on messages dispatches.
  # @param error [Exception] any error that was raised
  #
  # source://waterdrop//lib/waterdrop/producer/transactions.rb#260
  def transactional_reload_client_if_needed(error); end

  # Runs provided code with a transaction wrapper if transactions are enabled.
  # This allows us to simplify the async and sync batch dispatchers because we can ensure that
  # their internal dispatches will be wrapped only with a single transaction and not
  # a transaction per message
  #
  # @param block [Proc] code we want to run
  #
  # source://waterdrop//lib/waterdrop/producer/transactions.rb#175
  def with_transaction_if_transactional(&block); end

  # Error handling for transactional operations is a bit special. There are three types of
  # errors coming from librdkafka:
  #   - retryable - indicates that a given operation (like offset commit) can be retried after
  #     a backoff and that is should be operating later as expected. We try to retry those
  #     few times before finally failing.
  #   - fatal - errors that will not recover no matter what (for example being fenced out)
  #   - abortable - error from which we cannot recover but for which we should abort the
  #     current transaction.
  #
  # The code below handles this logic also publishing the appropriate notifications via our
  # notifications pipeline.
  #
  # @param action [Symbol] action type
  # @param allow_abortable [Boolean] should we allow for the abortable flow. This is set to
  #   false internally to prevent attempts to abort from failed abort operations
  #
  # source://waterdrop//lib/waterdrop/producer/transactions.rb#203
  def with_transactional_error_handling(action, allow_abortable: T.unsafe(nil)); end
end

# Contract to validate that input for transactional offset storage is correct
#
# source://waterdrop//lib/waterdrop/producer/transactions.rb#14
WaterDrop::Producer::Transactions::CONTRACT = T.let(T.unsafe(nil), WaterDrop::Contracts::TransactionalOffset)

# We should never reload producer if it was fenced, otherwise we could end up with some sort
# of weird race-conditions
#
# source://waterdrop//lib/waterdrop/producer/transactions.rb#9
WaterDrop::Producer::Transactions::NON_RELOADABLE_ERRORS = T.let(T.unsafe(nil), Array)

# Object that acts as a proxy allowing for alteration of certain low-level per-topic
# configuration and some other settings that users may find useful to alter, without having
# to create new producers with their underlying librdkafka instances.
#
# Since each librdkafka instance creates at least one TCP connection per broker, creating
# separate objects just to alter thing like `acks` may not be efficient and may lead to
# extensive usage of TCP connections, especially in bigger clusters.
#
# This variant object allows for "wrapping" of the producer with alteration of those settings
# in such a way, that two or more alterations can co-exist and share the same producer,
# effectively sharing the librdkafka client.
#
# Since this is an enhanced `SimpleDelegator` all `WaterDrop::Producer` APIs are preserved and
# a variant alteration can be used as a regular producer. The only important thing is to
# remember to only close it once.
#
# @note Not all settings are alterable. We only allow to alter things that are safe to be
#   altered as they have no impact on the producer. If there is a setting you consider
#   important and want to make it alterable, please open a GH issue for evaluation.
# @note Please be aware, that variant changes also affect buffers. If you overwrite the
#   `max_wait_timeout`, since buffers are shared (as they exist on producer level), flushing
#   may be impacted.
# @note `topic_config` is validated when created for the first time during message production.
#   This means, that configuration error may be raised only during dispatch. There is no
#   way out of this, since we need `librdkafka` instance to create the references.
#
# source://waterdrop//lib/waterdrop/producer/variant.rb#32
class WaterDrop::Producer::Variant < ::SimpleDelegator
  # @param producer [WaterDrop::Producer] producer for which we want to have a variant
  # @param max_wait_timeout [Integer, nil] alteration to max wait timeout or nil to use
  #   default
  # @param topic_config [Hash] extra topic configuration that can be altered.
  # @param default [Boolean] is this a default variant or an altered one
  # @return [Variant] a new instance of Variant
  # @see https://karafka.io/docs/Librdkafka-Configuration/#topic-configuration-properties
  #
  # source://waterdrop//lib/waterdrop/producer/variant.rb#47
  def initialize(producer, max_wait_timeout: T.unsafe(nil), topic_config: T.unsafe(nil), default: T.unsafe(nil)); end

  # source://waterdrop//lib/waterdrop/producer/variant.rb#78
  def buffer(*args, &block); end

  # source://waterdrop//lib/waterdrop/producer/variant.rb#78
  def buffer_many(*args, &block); end

  # @return [Boolean] is this a default variant for this producer
  #
  # source://waterdrop//lib/waterdrop/producer/variant.rb#63
  def default?; end

  # source://waterdrop//lib/waterdrop/producer/variant.rb#78
  def flush_async(*args, &block); end

  # source://waterdrop//lib/waterdrop/producer/variant.rb#78
  def flush_sync(*args, &block); end

  # Returns the value of attribute max_wait_timeout.
  #
  # source://waterdrop//lib/waterdrop/producer/variant.rb#39
  def max_wait_timeout; end

  # source://waterdrop//lib/waterdrop/producer/variant.rb#78
  def produce_async(*args, &block); end

  # source://waterdrop//lib/waterdrop/producer/variant.rb#78
  def produce_many_async(*args, &block); end

  # source://waterdrop//lib/waterdrop/producer/variant.rb#78
  def produce_many_sync(*args, &block); end

  # source://waterdrop//lib/waterdrop/producer/variant.rb#78
  def produce_sync(*args, &block); end

  # Returns the value of attribute producer.
  #
  # source://waterdrop//lib/waterdrop/producer/variant.rb#39
  def producer; end

  # Returns the value of attribute topic_config.
  #
  # source://waterdrop//lib/waterdrop/producer/variant.rb#39
  def topic_config; end

  # source://waterdrop//lib/waterdrop/producer/variant.rb#78
  def transaction(*args, &block); end

  # source://waterdrop//lib/waterdrop/producer/variant.rb#78
  def transaction?(*args, &block); end

  # source://waterdrop//lib/waterdrop/producer/variant.rb#78
  def transaction_mark_as_consumed(*args, &block); end

  # source://waterdrop//lib/waterdrop/producer/variant.rb#78
  def transactional?(*args, &block); end

  private

  # @return [Hash] hash representation for contract validation to ensure basic sanity of the
  #   settings.
  #
  # source://waterdrop//lib/waterdrop/producer/variant.rb#93
  def to_h; end
end

# Empty hash we use as defaults for topic config.
# When rdkafka-ruby detects empty hash, it will use the librdkafka defaults
#
# source://waterdrop//lib/waterdrop/producer/variant.rb#35
WaterDrop::Producer::Variant::EMPTY_HASH = T.let(T.unsafe(nil), Hash)

# Current WaterDrop version
#
# source://waterdrop//lib/waterdrop/version.rb#6
WaterDrop::VERSION = T.let(T.unsafe(nil), String)
