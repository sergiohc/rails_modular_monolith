# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `mailcatcher` gem.
# Please instead update this file by running `bin/tapioca gem mailcatcher`.


# source://mailcatcher//lib/mail_catcher.rb#10
module EventMachine
  private

  def add_oneshot_timer(_arg0); end
  def attach_fd(_arg0, _arg1); end
  def attach_sd(_arg0); end
  def bind_connect_server(_arg0, _arg1, _arg2, _arg3); end
  def close_connection(_arg0, _arg1); end
  def connect_server(_arg0, _arg1); end
  def connect_unix_server(_arg0); end
  def connection_paused?(_arg0); end
  def current_time; end
  def detach_fd(_arg0); end
  def epoll; end
  def epoll=(_arg0); end
  def epoll?; end
  def get_cipher_bits(_arg0); end
  def get_cipher_name(_arg0); end
  def get_cipher_protocol(_arg0); end
  def get_comm_inactivity_timeout(_arg0); end
  def get_connection_count; end
  def get_file_descriptor(_arg0); end
  def get_heartbeat_interval; end
  def get_idle_time(_arg0); end
  def get_max_timer_count; end
  def get_peer_cert(_arg0); end
  def get_peername(_arg0); end
  def get_pending_connect_timeout(_arg0); end
  def get_proxied_bytes(_arg0); end
  def get_simultaneous_accept_count; end
  def get_sni_hostname(_arg0); end
  def get_sock_opt(_arg0, _arg1, _arg2); end
  def get_sockname(_arg0); end
  def get_subprocess_pid(_arg0); end
  def get_subprocess_status(_arg0); end
  def initialize_event_machine; end
  def invoke_popen(_arg0); end
  def is_notify_readable(_arg0); end
  def is_notify_writable(_arg0); end
  def kqueue; end
  def kqueue=(_arg0); end
  def kqueue?; end
  def library_type; end
  def num_close_scheduled; end
  def open_udp_socket(_arg0, _arg1); end
  def pause_connection(_arg0); end
  def read_keyboard; end
  def release_machine; end
  def report_connection_error_status(_arg0); end
  def resume_connection(_arg0); end
  def run_machine; end
  def run_machine_once; end
  def run_machine_without_threads; end
  def send_data(_arg0, _arg1, _arg2); end
  def send_datagram(_arg0, _arg1, _arg2, _arg3, _arg4); end
  def send_file_data(_arg0, _arg1); end
  def set_comm_inactivity_timeout(_arg0, _arg1); end
  def set_heartbeat_interval(_arg0); end
  def set_max_timer_count(_arg0); end
  def set_notify_readable(_arg0, _arg1); end
  def set_notify_writable(_arg0, _arg1); end
  def set_pending_connect_timeout(_arg0, _arg1); end
  def set_rlimit_nofile(_arg0); end
  def set_simultaneous_accept_count(_arg0); end
  def set_sock_opt(_arg0, _arg1, _arg2, _arg3); end
  def set_timer_quantum(_arg0); end
  def set_tls_parms(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9); end
  def setuid_string(_arg0); end
  def signal_loopbreak; end
  def ssl?; end
  def start_proxy(_arg0, _arg1, _arg2, _arg3); end
  def start_tcp_server(_arg0, _arg1); end
  def start_tls(_arg0); end
  def start_unix_server(_arg0); end
  def stop; end
  def stop_proxy(_arg0); end
  def stop_tcp_server(_arg0); end
  def stopping?; end
  def unwatch_filename(_arg0); end
  def unwatch_pid(_arg0); end
  def watch_filename(_arg0); end
  def watch_pid(_arg0); end

  class << self
    # source://eventmachine/1.2.7/lib/em/callback.rb#47
    def Callback(object = T.unsafe(nil), method = T.unsafe(nil), &blk); end

    # source://eventmachine/1.2.7/lib/eventmachine.rb#1563
    def _open_file_for_writing(filename, handler = T.unsafe(nil)); end

    def add_oneshot_timer(_arg0); end

    # source://eventmachine/1.2.7/lib/eventmachine.rb#351
    def add_periodic_timer(*args, &block); end

    # source://eventmachine/1.2.7/lib/eventmachine.rb#291
    def add_shutdown_hook(&block); end

    # source://eventmachine/1.2.7/lib/eventmachine.rb#323
    def add_timer(*args, &block); end

    # source://eventmachine/1.2.7/lib/eventmachine.rb#741
    def attach(io, handler = T.unsafe(nil), *args, &blk); end

    def attach_fd(_arg0, _arg1); end

    # source://eventmachine/1.2.7/lib/eventmachine.rb#746
    def attach_io(io, watch_mode, handler = T.unsafe(nil), *args); end

    def attach_sd(_arg0); end

    # source://eventmachine/1.2.7/lib/eventmachine.rb#541
    def attach_server(sock, handler = T.unsafe(nil), *args, &block); end

    # source://eventmachine/1.2.7/lib/eventmachine.rb#661
    def bind_connect(bind_addr, bind_port, server, port = T.unsafe(nil), handler = T.unsafe(nil), *args); end

    def bind_connect_server(_arg0, _arg1, _arg2, _arg3); end

    # source://eventmachine/1.2.7/lib/eventmachine.rb#363
    def cancel_timer(timer_or_sig); end

    # source://eventmachine/1.2.7/lib/eventmachine.rb#261
    def cleanup_machine; end

    def close_connection(_arg0, _arg1); end

    # source://eventmachine/1.2.7/lib/eventmachine.rb#631
    def connect(server, port = T.unsafe(nil), handler = T.unsafe(nil), *args, &blk); end

    def connect_server(_arg0, _arg1); end

    # source://eventmachine/1.2.7/lib/eventmachine.rb#813
    def connect_unix_domain(socketname, *args, &blk); end

    def connect_unix_server(_arg0); end

    # source://eventmachine/1.2.7/lib/eventmachine.rb#955
    def connection_count; end

    def connection_paused?(_arg0); end
    def current_time; end

    # source://eventmachine/1.2.7/lib/eventmachine.rb#1043
    def defer(op = T.unsafe(nil), callback = T.unsafe(nil), errback = T.unsafe(nil), &blk); end

    # source://eventmachine/1.2.7/lib/eventmachine.rb#1095
    def defers_finished?; end

    def detach_fd(_arg0); end

    # source://eventmachine/1.2.7/lib/eventmachine.rb#1440
    def disable_proxy(from); end

    # source://eventmachine/1.2.7/lib/eventmachine.rb#1430
    def enable_proxy(from, to, bufsize = T.unsafe(nil), length = T.unsafe(nil)); end

    def epoll; end
    def epoll=(_arg0); end
    def epoll?; end

    # source://eventmachine/1.2.7/lib/eventmachine.rb#1363
    def error_handler(cb = T.unsafe(nil), &blk); end

    # source://eventmachine/1.2.7/lib/eventmachine.rb#1463
    def event_callback(conn_binding, opcode, data); end

    # source://eventmachine/1.2.7/lib/eventmachine.rb#243
    def fork_reactor(&block); end

    def get_cipher_bits(_arg0); end
    def get_cipher_name(_arg0); end
    def get_cipher_protocol(_arg0); end
    def get_comm_inactivity_timeout(_arg0); end
    def get_connection_count; end
    def get_file_descriptor(_arg0); end
    def get_heartbeat_interval; end
    def get_idle_time(_arg0); end
    def get_max_timer_count; end

    # source://eventmachine/1.2.7/lib/eventmachine.rb#924
    def get_max_timers; end

    def get_peer_cert(_arg0); end
    def get_peername(_arg0); end
    def get_pending_connect_timeout(_arg0); end
    def get_proxied_bytes(_arg0); end
    def get_simultaneous_accept_count; end
    def get_sni_hostname(_arg0); end
    def get_sock_opt(_arg0, _arg1, _arg2); end
    def get_sockname(_arg0); end
    def get_subprocess_pid(_arg0); end
    def get_subprocess_status(_arg0); end

    # source://eventmachine/1.2.7/lib/eventmachine.rb#1449
    def heartbeat_interval; end

    # source://eventmachine/1.2.7/lib/eventmachine.rb#1458
    def heartbeat_interval=(time); end

    def initialize_event_machine; end
    def invoke_popen(_arg0); end
    def is_notify_readable(_arg0); end
    def is_notify_writable(_arg0); end

    # source://eventmachine/1.2.7/lib/eventmachine.rb#1574
    def klass_from_handler(klass = T.unsafe(nil), handler = T.unsafe(nil), *args); end

    def kqueue; end
    def kqueue=(_arg0); end
    def kqueue?; end
    def library_type; end

    # source://eventmachine/1.2.7/lib/eventmachine.rb#1121
    def next_tick(pr = T.unsafe(nil), &block); end

    def num_close_scheduled; end

    # source://eventmachine/1.2.7/lib/eventmachine.rb#872
    def open_datagram_socket(address, port, handler = T.unsafe(nil), *args); end

    # source://eventmachine/1.2.7/lib/eventmachine.rb#1235
    def open_keyboard(handler = T.unsafe(nil), *args); end

    def open_udp_socket(_arg0, _arg1); end
    def pause_connection(_arg0); end

    # source://eventmachine/1.2.7/lib/eventmachine.rb#1198
    def popen(cmd, handler = T.unsafe(nil), *args); end

    # Monkey patch fix for 10deb4
    # See https://github.com/eventmachine/eventmachine/issues/569
    #
    # @return [Boolean]
    #
    # source://mailcatcher//lib/mail_catcher.rb#13
    def reactor_running?; end

    # source://eventmachine/1.2.7/lib/eventmachine.rb#79
    def reactor_thread; end

    # source://eventmachine/1.2.7/lib/eventmachine.rb#227
    def reactor_thread?; end

    def read_keyboard; end

    # source://eventmachine/1.2.7/lib/eventmachine.rb#781
    def reconnect(server, port, handler); end

    def release_machine; end
    def report_connection_error_status(_arg0); end
    def resume_connection(_arg0); end

    # source://eventmachine/1.2.7/lib/eventmachine.rb#149
    def run(blk = T.unsafe(nil), tail = T.unsafe(nil), &block); end

    # source://eventmachine/1.2.7/lib/eventmachine.rb#218
    def run_block(&block); end

    # source://eventmachine/1.2.7/lib/eventmachine.rb#967
    def run_deferred_callbacks; end

    def run_machine; end
    def run_machine_once; end
    def run_machine_without_threads; end

    # source://eventmachine/1.2.7/lib/eventmachine.rb#233
    def schedule(*a, &b); end

    def send_data(_arg0, _arg1, _arg2); end
    def send_datagram(_arg0, _arg1, _arg2, _arg3, _arg4); end
    def send_file_data(_arg0, _arg1); end
    def set_comm_inactivity_timeout(_arg0, _arg1); end

    # source://eventmachine/1.2.7/lib/eventmachine.rb#1168
    def set_descriptor_table_size(n_descriptors = T.unsafe(nil)); end

    # source://eventmachine/1.2.7/lib/eventmachine.rb#1149
    def set_effective_user(username); end

    def set_heartbeat_interval(_arg0); end
    def set_max_timer_count(_arg0); end

    # source://eventmachine/1.2.7/lib/eventmachine.rb#917
    def set_max_timers(ct); end

    def set_notify_readable(_arg0, _arg1); end
    def set_notify_writable(_arg0, _arg1); end
    def set_pending_connect_timeout(_arg0, _arg1); end

    # source://eventmachine/1.2.7/lib/eventmachine.rb#902
    def set_quantum(mills); end

    def set_rlimit_nofile(_arg0); end
    def set_simultaneous_accept_count(_arg0); end
    def set_sock_opt(_arg0, _arg1, _arg2, _arg3); end
    def set_timer_quantum(_arg0); end
    def set_tls_parms(_arg0, _arg1, _arg2, _arg3, _arg4, _arg5, _arg6, _arg7, _arg8, _arg9); end
    def setuid_string(_arg0); end
    def signal_loopbreak; end

    # source://eventmachine/1.2.7/lib/em/spawnable.rb#69
    def spawn(&block); end

    # source://eventmachine/1.2.7/lib/eventmachine.rb#1065
    def spawn_threadpool; end

    def ssl?; end
    def start_proxy(_arg0, _arg1, _arg2, _arg3); end

    # source://eventmachine/1.2.7/lib/eventmachine.rb#517
    def start_server(server, port = T.unsafe(nil), handler = T.unsafe(nil), *args, &block); end

    def start_tcp_server(_arg0, _arg1); end
    def start_tls(_arg0); end

    # source://eventmachine/1.2.7/lib/eventmachine.rb#561
    def start_unix_domain_server(filename, *args, &block); end

    def start_unix_server(_arg0); end
    def stop; end

    # source://eventmachine/1.2.7/lib/eventmachine.rb#417
    def stop_event_loop; end

    def stop_proxy(_arg0); end

    # source://eventmachine/1.2.7/lib/eventmachine.rb#551
    def stop_server(signature); end

    def stop_tcp_server(_arg0); end
    def stopping?; end

    # source://eventmachine/1.2.7/lib/em/processes.rb#112
    def system(cmd, *args, &cb); end

    # source://eventmachine/1.2.7/lib/eventmachine.rb#1105
    def threadpool; end

    # source://eventmachine/1.2.7/lib/eventmachine.rb#1109
    def threadpool_size; end

    # source://eventmachine/1.2.7/lib/eventmachine.rb#1109
    def threadpool_size=(_arg0); end

    # source://eventmachine/1.2.7/lib/em/tick_loop.rb#3
    def tick_loop(*a, &b); end

    def unwatch_filename(_arg0); end
    def unwatch_pid(_arg0); end

    # source://eventmachine/1.2.7/lib/eventmachine.rb#731
    def watch(io, handler = T.unsafe(nil), *args, &blk); end

    # source://eventmachine/1.2.7/lib/eventmachine.rb#1309
    def watch_file(filename, handler = T.unsafe(nil), *args); end

    def watch_filename(_arg0); end
    def watch_pid(_arg0); end

    # source://eventmachine/1.2.7/lib/eventmachine.rb#1340
    def watch_process(pid, handler = T.unsafe(nil), *args); end

    # source://eventmachine/1.2.7/lib/em/spawnable.rb#76
    def yield(&block); end

    # source://eventmachine/1.2.7/lib/em/spawnable.rb#81
    def yield_and_notify(&block); end
  end
end

class EventMachine::ConnectionError < ::RuntimeError; end
class EventMachine::ConnectionNotBound < ::RuntimeError; end
class EventMachine::InvalidSignature < ::RuntimeError; end
class EventMachine::NoHandlerForAcceptedConnection < ::RuntimeError; end
class EventMachine::UnknownTimerFired < ::RuntimeError; end
class EventMachine::Unsupported < ::RuntimeError; end

# source://mailcatcher//lib/mail_catcher/version.rb#3
module MailCatcher
  extend ::MailCatcher

  # @return [Boolean]
  #
  # source://mailcatcher//lib/mail_catcher.rb#44
  def browsable?; end

  # source://mailcatcher//lib/mail_catcher.rb#48
  def browse(url); end

  # @return [Boolean]
  #
  # source://mailcatcher//lib/mail_catcher.rb#30
  def development?; end

  # source://mailcatcher//lib/mail_catcher.rb#26
  def env; end

  # source://mailcatcher//lib/mail_catcher.rb#56
  def log_exception(message, context, exception); end

  # source://mailcatcher//lib/mail_catcher.rb#80
  def options; end

  # source://mailcatcher//lib/mail_catcher.rb#88
  def parse!(arguments = T.unsafe(nil), defaults = T.unsafe(nil)); end

  # source://mailcatcher//lib/mail_catcher.rb#221
  def quit!; end

  # @return [Boolean]
  #
  # source://mailcatcher//lib/mail_catcher.rb#84
  def quittable?; end

  # source://mailcatcher//lib/mail_catcher.rb#160
  def run!(options = T.unsafe(nil)); end

  # @return [Boolean]
  #
  # source://mailcatcher//lib/mail_catcher.rb#34
  def which?(command); end

  # @return [Boolean]
  #
  # source://mailcatcher//lib/mail_catcher.rb#40
  def windows?; end

  protected

  # source://mailcatcher//lib/mail_catcher.rb#233
  def http_url; end

  # source://mailcatcher//lib/mail_catcher.rb#237
  def rescue_port(port); end

  # source://mailcatcher//lib/mail_catcher.rb#229
  def smtp_url; end
end

# source://mailcatcher//lib/mail_catcher/bus.rb#6
MailCatcher::Bus = T.let(T.unsafe(nil), EventMachine::Channel)

# source://mailcatcher//lib/mail_catcher/mail.rb#8
module MailCatcher::Mail
  extend ::MailCatcher::Mail

  # source://mailcatcher//lib/mail_catcher/mail.rb#44
  def add_message(message); end

  # source://mailcatcher//lib/mail_catcher/mail.rb#65
  def add_message_part(*args); end

  # source://mailcatcher//lib/mail_catcher/mail.rb#9
  def db; end

  # source://mailcatcher//lib/mail_catcher/mail.rb#156
  def delete!; end

  # source://mailcatcher//lib/mail_catcher/mail.rb#165
  def delete_message!(message_id); end

  # source://mailcatcher//lib/mail_catcher/mail.rb#174
  def delete_older_messages!(count = T.unsafe(nil)); end

  # source://mailcatcher//lib/mail_catcher/mail.rb#70
  def latest_created_at; end

  # source://mailcatcher//lib/mail_catcher/mail.rb#84
  def message(id); end

  # source://mailcatcher//lib/mail_catcher/mail.rb#115
  def message_attachments(id); end

  # @return [Boolean]
  #
  # source://mailcatcher//lib/mail_catcher/mail.rb#98
  def message_has_html?(id); end

  # @return [Boolean]
  #
  # source://mailcatcher//lib/mail_catcher/mail.rb#103
  def message_has_plain?(id); end

  # source://mailcatcher//lib/mail_catcher/mail.rb#122
  def message_part(message_id, part_id); end

  # source://mailcatcher//lib/mail_catcher/mail.rb#147
  def message_part_cid(message_id, cid); end

  # source://mailcatcher//lib/mail_catcher/mail.rb#134
  def message_part_html(message_id); end

  # source://mailcatcher//lib/mail_catcher/mail.rb#143
  def message_part_plain(message_id); end

  # source://mailcatcher//lib/mail_catcher/mail.rb#128
  def message_part_type(message_id, part_type); end

  # source://mailcatcher//lib/mail_catcher/mail.rb#108
  def message_parts(id); end

  # source://mailcatcher//lib/mail_catcher/mail.rb#92
  def message_source(id); end

  # source://mailcatcher//lib/mail_catcher/mail.rb#75
  def messages; end
end

# source://mailcatcher//lib/mail_catcher/smtp.rb#7
class MailCatcher::Smtp < ::EventMachine::Protocols::SmtpServer
  # source://mailcatcher//lib/mail_catcher/smtp.rb#20
  def current_message; end

  # We override EM's mail from processing to allow multiple mail-from commands
  # per [RFC 2821](https://tools.ietf.org/html/rfc2821#section-4.1.1.2)
  #
  # source://mailcatcher//lib/mail_catcher/smtp.rb#10
  def process_mail_from(sender); end

  # source://mailcatcher//lib/mail_catcher/smtp.rb#47
  def receive_data_chunk(lines); end

  # source://mailcatcher//lib/mail_catcher/smtp.rb#57
  def receive_message; end

  # source://mailcatcher//lib/mail_catcher/smtp.rb#40
  def receive_recipient(recipient); end

  # source://mailcatcher//lib/mail_catcher/smtp.rb#24
  def receive_reset; end

  # source://mailcatcher//lib/mail_catcher/smtp.rb#30
  def receive_sender(sender); end
end

# source://mailcatcher//lib/mail_catcher/version.rb#4
MailCatcher::VERSION = T.let(T.unsafe(nil), String)

# source://mailcatcher//lib/mailcatcher.rb#5
Mailcatcher = MailCatcher

# source://mailcatcher//lib/mail_catcher/web/application.rb#30
class Sinatra::Request < ::Rack::Request
  include ::Faye::WebSocket::Adapter

  # source://sinatra/3.2.0/lib/sinatra/base.rb#28
  def accept; end

  # source://sinatra/3.2.0/lib/sinatra/base.rb#40
  def accept?(type); end

  # source://sinatra/3.2.0/lib/sinatra/base.rb#58
  def forwarded?; end

  # source://sinatra/3.2.0/lib/sinatra/base.rb#66
  def idempotent?; end

  # source://sinatra/3.2.0/lib/sinatra/base.rb#70
  def link?; end

  # source://sinatra/3.2.0/lib/sinatra/base.rb#78
  def params; end

  # source://sinatra/3.2.0/lib/sinatra/base.rb#44
  def preferred_type(*types); end

  # source://sinatra/3.2.0/lib/sinatra/base.rb#62
  def safe?; end

  # source://rack/2.2.9/lib/rack/request.rb#350
  def secure?; end

  # source://sinatra/3.2.0/lib/sinatra/base.rb#74
  def unlink?; end
end

module Thin::Backends; end

# Faye's adapter isn't smart enough to close websockets when thin is stopped,
# so we teach it to do so.
#
# source://mailcatcher//lib/mail_catcher/web/application.rb#17
class Thin::Backends::Base
  # source://thin/1.8.2/lib/thin/backends/base.rb#47
  def initialize; end

  # source://thin/1.8.2/lib/thin/backends/base.rb#114
  def close; end

  # source://thin/1.8.2/lib/thin/backends/base.rb#103
  def config; end

  # source://thin/1.8.2/lib/thin/backends/base.rb#127
  def connection_finished(connection); end

  # source://thin/1.8.2/lib/thin/backends/base.rb#136
  def empty?; end

  # source://thin/1.8.2/lib/thin/backends/base.rb#21
  def maximum_connections; end

  # source://thin/1.8.2/lib/thin/backends/base.rb#21
  def maximum_connections=(_arg0); end

  # source://thin/1.8.2/lib/thin/backends/base.rb#24
  def maximum_persistent_connections; end

  # source://thin/1.8.2/lib/thin/backends/base.rb#24
  def maximum_persistent_connections=(_arg0); end

  # source://thin/1.8.2/lib/thin/backends/base.rb#45
  def no_epoll; end

  # source://thin/1.8.2/lib/thin/backends/base.rb#45
  def no_epoll=(_arg0); end

  # source://thin/1.8.2/lib/thin/backends/base.rb#42
  def persistent_connection_count; end

  # source://thin/1.8.2/lib/thin/backends/base.rb#42
  def persistent_connection_count=(_arg0); end

  # source://thin/1.8.2/lib/thin/backends/base.rb#118
  def running?; end

  # source://thin/1.8.2/lib/thin/backends/base.rb#15
  def server; end

  # source://thin/1.8.2/lib/thin/backends/base.rb#15
  def server=(_arg0); end

  # source://thin/1.8.2/lib/thin/backends/base.rb#141
  def size; end

  # source://thin/1.8.2/lib/thin/backends/base.rb#38
  def ssl=(_arg0); end

  # source://thin/1.8.2/lib/thin/backends/base.rb#39
  def ssl?; end

  # source://thin/1.8.2/lib/thin/backends/base.rb#38
  def ssl_options=(_arg0); end

  # source://thin/1.8.2/lib/thin/backends/base.rb#62
  def start; end

  # source://thin/1.8.2/lib/thin/backends/base.rb#122
  def started_reactor?; end

  # source://mailcatcher//lib/mail_catcher/web/application.rb#20
  def stop; end

  # source://thin/1.8.2/lib/thin/backends/base.rb#92
  def stop!; end

  # source://mailcatcher//lib/mail_catcher/web/application.rb#20
  def thin_stop; end

  # source://thin/1.8.2/lib/thin/backends/base.rb#34
  def threaded=(_arg0); end

  # source://thin/1.8.2/lib/thin/backends/base.rb#35
  def threaded?; end

  # source://thin/1.8.2/lib/thin/backends/base.rb#27
  def threadpool_size; end

  # source://thin/1.8.2/lib/thin/backends/base.rb#28
  def threadpool_size=(size); end

  # source://thin/1.8.2/lib/thin/backends/base.rb#18
  def timeout; end

  # source://thin/1.8.2/lib/thin/backends/base.rb#18
  def timeout=(_arg0); end

  protected

  # source://thin/1.8.2/lib/thin/backends/base.rb#147
  def initialize_connection(connection); end
end
