# typed: true

# DO NOT EDIT MANUALLY
# This is an autogenerated file for types exported from the `roda` gem.
# Please instead update this file by running `bin/tapioca gem roda`.


# The main class for Roda.  Roda is built completely out of plugins, with the
# default plugin being Roda::RodaPlugins::Base, so this class is mostly empty
# except for some constants.
#
# source://roda//lib/roda/cache.rb#5
class Roda
  include ::Roda::RodaPlugins::Base::InstanceMethods
  extend ::Roda::RodaPlugins::Base::ClassMethods
end

# A thread safe cache class, offering only #[] and #[]= methods,
# each protected by a mutex.
#
# source://roda//lib/roda/cache.rb#8
class Roda::RodaCache
  # Create a new thread safe cache.
  #
  # @return [RodaCache] a new instance of RodaCache
  #
  # source://roda//lib/roda/cache.rb#10
  def initialize; end

  # Make getting value from underlying hash thread safe.
  #
  # source://roda//lib/roda/cache.rb#16
  def [](key); end

  # Make setting value in underlying hash thread safe.
  #
  # source://roda//lib/roda/cache.rb#21
  def []=(key, value); end

  # Return the frozen internal hash.  The internal hash can then
  # be accessed directly since it is frozen and there are no
  # thread safety issues.
  #
  # source://roda//lib/roda/cache.rb#28
  def freeze; end

  private

  # Create a copy of the cache with a separate mutex.
  #
  # source://roda//lib/roda/cache.rb#35
  def initialize_copy(other); end
end

# Error class raised by Roda
#
# source://roda//lib/roda.rb#15
class Roda::RodaError < ::StandardError; end

# The major version of Roda, updated only for major changes that are
# likely to require modification to Roda apps.
#
# source://roda//lib/roda/version.rb#4
Roda::RodaMajorVersion = T.let(T.unsafe(nil), Integer)

# The minor version of Roda, updated for new feature releases of Roda.
#
# source://roda//lib/roda/version.rb#7
Roda::RodaMinorVersion = T.let(T.unsafe(nil), Integer)

# The patch version of Roda, updated only for bug fixes from the last
# feature release.
#
# source://roda//lib/roda/version.rb#11
Roda::RodaPatchVersion = T.let(T.unsafe(nil), Integer)

# Module in which all Roda plugins should be stored. Also contains logic for
# registering and loading plugins.
#
# source://roda//lib/roda/request.rb#26
module Roda::RodaPlugins
  class << self
    # Deprecate the constant with the given name in the given module,
    # if the ruby version supports it.
    #
    # source://roda//lib/roda/plugins.rb#45
    def deprecate_constant(mod, name); end

    # If the registered plugin already exists, use it.  Otherwise,
    # require it and return it.  This raises a LoadError if such a
    # plugin doesn't exist, or a RodaError if it exists but it does
    # not register itself correctly.
    #
    # source://roda//lib/roda/plugins.rb#26
    def load_plugin(name); end

    # Register the given plugin with Roda, so that it can be loaded using #plugin
    # with a symbol.  Should be used by plugin files. Example:
    #
    #   Roda::RodaPlugins.register_plugin(:plugin_name, PluginModule)
    #
    # source://roda//lib/roda/plugins.rb#39
    def register_plugin(name, mod); end

    def warn(*msgs, uplevel: T.unsafe(nil), category: T.unsafe(nil)); end
  end
end

# The base plugin for Roda, implementing all default functionality.
# Methods are put into a plugin so future plugins can easily override
# them and call super to get the default behavior.
#
# source://roda//lib/roda/request.rb#27
module Roda::RodaPlugins::Base; end

# source://roda//lib/roda/plugins/_base64.rb#6
module Roda::RodaPlugins::Base64_
  class << self
    # source://roda//lib/roda/plugins/_base64.rb#9
    def decode64(str); end

    # source://roda//lib/roda/plugins/_base64.rb#26
    def urlsafe_decode64(str); end

    # source://roda//lib/roda/plugins/_base64.rb#20
    def urlsafe_encode64(bin); end
  end
end

# Class methods for the Roda class.
#
# source://roda//lib/roda.rb#31
module Roda::RodaPlugins::Base::ClassMethods
  # The rack application that this class uses.
  #
  # source://roda//lib/roda.rb#33
  def app; end

  # Call the internal rack application with the given environment.
  # This allows the class itself to be used as a rack application.
  # However, for performance, it's better to use #app to get direct
  # access to the underlying rack app.
  #
  # source://roda//lib/roda.rb#52
  def call(env); end

  # Clear the middleware stack
  #
  # source://roda//lib/roda.rb#57
  def clear_middleware!; end

  # Define an instance method using the block with the provided name and
  # expected arity.  If the name is given as a Symbol, it is used directly.
  # If the name is given as a String, a unique name will be generated using
  # that string.  The expected arity should be either 0 (no arguments),
  # 1 (single argument), or :any (any number of arguments).
  #
  # If the :check_arity app option is not set to false, Roda will check that
  # the arity of the block matches the expected arity, and compensate for
  # cases where it does not.  If it is set to :warn, Roda will warn in the
  # cases where the arity does not match what is expected.
  #
  # If the expected arity is :any, Roda must perform a dynamic arity check
  # when the method is called, which can hurt performance even in the case
  # where the arity matches.  The :check_dynamic_arity app option can be
  # set to false to turn off the dynamic arity checks.  The
  # :check_dynamic_arity app option can be to :warn to warn if Roda needs
  # to adjust arity dynamically.
  #
  # Roda only checks arity for regular blocks, not lambda blocks, as the
  # fixes Roda uses for regular blocks would not work for lambda blocks.
  #
  # Roda does not support blocks with required keyword arguments if the
  # expected arity is 0 or 1.
  #
  # source://roda//lib/roda.rb#85
  def define_roda_method(meth, expected_arity, &block); end

  # Expand the given path, using the root argument as the base directory.
  #
  # source://roda//lib/roda.rb#183
  def expand_path(path, root = T.unsafe(nil)); end

  # Freeze the internal state of the class, to avoid thread safety issues at runtime.
  # It's optional to call this method, as nothing should be modifying the
  # internal state at runtime anyway, but this makes sure an exception will
  # be raised if you try to modify the internal state after calling this.
  #
  # Note that freezing the class prevents you from subclassing it, mostly because
  # it would cause some plugins to break.
  #
  # source://roda//lib/roda.rb#194
  def freeze; end

  # Rebuild the _roda_before and _roda_after methods whenever a plugin might
  # have added a _roda_before_* or _roda_after_* method.
  #
  # source://roda//lib/roda.rb#234
  def include(*a); end

  # Whether middleware from the current class should be inherited by subclasses.
  # True by default, should be set to false when using a design where the parent
  # class accepts requests and uses run to dispatch the request to a subclass.
  #
  # source://roda//lib/roda.rb#40
  def inherit_middleware; end

  # Whether middleware from the current class should be inherited by subclasses.
  # True by default, should be set to false when using a design where the parent
  # class accepts requests and uses run to dispatch the request to a subclass.
  #
  # source://roda//lib/roda.rb#40
  def inherit_middleware=(_arg0); end

  # When inheriting Roda, copy the shared data into the subclass,
  # and setup the request and response subclasses.
  #
  # @raise [RodaError]
  #
  # source://roda//lib/roda.rb#243
  def inherited(subclass); end

  # The settings/options hash for the current class.
  #
  # source://roda//lib/roda.rb#43
  def opts; end

  # Load a new plugin into the current class.  A plugin can be a module
  # which is used directly, or a symbol representing a registered plugin
  # which will be required and then used. Returns nil.
  #
  # Note that you should not load plugins into a Roda class after the
  # class has been subclassed, as doing so can break the subclasses.
  #
  #   Roda.plugin PluginModule
  #   Roda.plugin :csrf
  #
  # @raise [RodaError]
  #
  # source://roda//lib/roda.rb#283
  def plugin(plugin, *args, **_arg2, &block); end

  # Setup routing tree for the current Roda application, and build the
  # underlying rack application using the stored middleware. Requires
  # a block, which is yielded the request.  By convention, the block
  # argument should be named +r+.  Example:
  #
  #   Roda.route do |r|
  #     r.root do
  #       "Root"
  #     end
  #   end
  #
  # This should only be called once per class, and if called multiple
  # times will overwrite the previous routing.
  #
  # source://roda//lib/roda.rb#320
  def route(&block); end

  # The route block that this class uses.
  #
  # source://roda//lib/roda.rb#46
  def route_block; end

  # Add a middleware to use for the rack application.  Must be
  # called before calling #route to have an effect. Example:
  #
  #   Roda.use Rack::ShowExceptions
  #
  # source://roda//lib/roda.rb#337
  def use(*args, **_arg1, &block); end

  private

  # Return the number of required argument, optional arguments,
  # whether the callable accepts any additional arguments,
  # and whether the callable accepts keyword arguments (true, false
  # or :required).
  #
  # source://roda//lib/roda.rb#351
  def _define_roda_method_arg_numbers(callable); end

  # The base rack app to use, before middleware is added.
  #
  # source://roda//lib/roda.rb#382
  def base_rack_app_callable(new_api = T.unsafe(nil)); end

  # Build the rack app to use
  #
  # source://roda//lib/roda.rb#392
  def build_rack_app; end

  # Modify the route block to use for any route block provided as input,
  # which can include route blocks that are delegated to by the main route block.
  # Can be modified by plugins.
  #
  # source://roda//lib/roda.rb#407
  def convert_route_block(block); end

  # Build a _roda_after method that calls each _roda_after_* method
  # in order, if any _roda_after_* methods are defined. Also, use
  # the internal after hook plugin if the _roda_after method is defined.
  #
  # source://roda//lib/roda.rb#431
  def def_roda_after; end

  # Build a _roda_before method that calls each _roda_before_* method
  # in order, if any _roda_before_* methods are defined. Also, rebuild
  # the route block if a _roda_before method is defined.
  #
  # source://roda//lib/roda.rb#414
  def def_roda_before; end

  # The route block to use when building the rack app (or other initial
  # entry point to the route block).
  # By default, modifies the rack app route block to support before hooks
  # if any before hooks are defined.
  # Can be modified by plugins.
  #
  # source://roda//lib/roda.rb#450
  def rack_app_route_block(block); end

  # source://roda//lib/roda.rb#475
  def roda_method_name(suffix); end

  # Whether the new dispatch API should be used.
  #
  # @return [Boolean]
  #
  # source://roda//lib/roda.rb#455
  def use_new_dispatch_api?; end
end

# Instance methods for the Roda class.
#
# In addition to the listed methods, the following two methods are available:
#
# request :: The instance of the request class related to this request.
#            This is the same object yielded by Roda.route.
# response :: The instance of the response class related to this request.
#
# source://roda//lib/roda.rb#487
module Roda::RodaPlugins::Base::InstanceMethods
  # Create a request and response of the appropriate class
  #
  # source://roda//lib/roda.rb#489
  def initialize(env); end

  # Handle dispatching to the main route, catching :halt and handling
  # the result of the block.
  #
  # source://roda//lib/roda.rb#497
  def _roda_handle_main_route; end

  # Treat the given block as a routing block, catching :halt if
  # thrown by the block.
  #
  # source://roda//lib/roda.rb#507
  def _roda_handle_route; end

  # Default implementation of the main route, usually overridden
  # by Roda.route.
  #
  # source://roda//lib/roda.rb#516
  def _roda_main_route(_); end

  # Run the main route block with the request.  Designed for
  # extension by plugins
  #
  # source://roda//lib/roda.rb#521
  def _roda_run_main_route(r); end

  # Deprecated method for the previous main route dispatch API.
  #
  # source://roda//lib/roda.rb#526
  def call(&block); end

  # The environment hash for the current request. Example:
  #
  #   env['REQUEST_METHOD'] # => 'GET'
  #
  # source://roda//lib/roda.rb#543
  def env; end

  # The class-level options hash.  This should probably not be
  # modified at the instance level. Example:
  #
  #   Roda.plugin :render
  #   Roda.route do |r|
  #     opts[:render_opts].inspect
  #   end
  #
  # source://roda//lib/roda.rb#554
  def opts; end

  def request; end
  def response; end

  # The session hash for the current request. Raises RodaError
  # if no session exists. Example:
  #
  #   session # => {}
  #
  # source://roda//lib/roda.rb#570
  def session; end

  private

  # Deprecated method for the previous main route dispatch API.
  # Deprecated private alias for internal use
  #
  # source://roda//lib/roda.rb#526
  def _call(&block); end
end

# Class methods for RodaRequest
#
# source://roda//lib/roda/request.rb#29
module Roda::RodaPlugins::Base::RequestClassMethods
  # Return the cached pattern for the given object.  If the object is
  # not already cached, yield to get the basic pattern, and convert the
  # basic pattern to a pattern that does not match partial segments.
  #
  # source://roda//lib/roda/request.rb#39
  def cached_matcher(obj); end

  # Since RodaRequest is anonymously subclassed when Roda is subclassed,
  # and then assigned to a constant of the Roda subclass, make inspect
  # reflect the likely name for the class.
  #
  # source://roda//lib/roda/request.rb#52
  def inspect; end

  # The cache to use for match patterns for this request class.
  #
  # source://roda//lib/roda/request.rb#34
  def match_pattern_cache; end

  # The cache to use for match patterns for this request class.
  #
  # source://roda//lib/roda/request.rb#34
  def match_pattern_cache=(_arg0); end

  # Reference to the Roda class related to this request class.
  #
  # source://roda//lib/roda/request.rb#31
  def roda_class; end

  # Reference to the Roda class related to this request class.
  #
  # source://roda//lib/roda/request.rb#31
  def roda_class=(_arg0); end

  private

  # The pattern to use for consuming, based on the given argument.  The returned
  # pattern requires the path starts with a string and does not match partial
  # segments.
  #
  # source://roda//lib/roda/request.rb#61
  def consume_pattern(pattern); end
end

# Instance methods for RodaRequest, mostly related to handling routing
# for the request.
#
# source://roda//lib/roda/request.rb#68
module Roda::RodaPlugins::Base::RequestMethods
  # Store the roda instance and environment.
  #
  # source://roda//lib/roda/request.rb#84
  def initialize(scope, env); end

  # Handle match block return values.  By default, if a string is given
  # and the response is empty, use the string as the response body.
  #
  # source://roda//lib/roda/request.rb#93
  def block_result(result); end

  # The current captures for the request.  This gets modified as routing
  # occurs.
  #
  # source://roda//lib/roda/request.rb#77
  def captures; end

  # Match GET requests.  If no arguments are provided, matches all GET
  # requests, otherwise, matches only GET requests where the arguments
  # given fully consume the path.
  #
  # source://roda//lib/roda/request.rb#103
  def get(*args, &block); end

  # Immediately stop execution of the route block and return the given
  # rack response array of status, headers, and body.  If no argument
  # is given, uses the current response.
  #
  #   r.halt [200, {'Content-Type'=>'text/html'}, ['Hello World!']]
  #
  #   response.status = 200
  #   response['Content-Type'] = 'text/html'
  #   response.write 'Hello World!'
  #   r.halt
  #
  # source://roda//lib/roda/request.rb#117
  def halt(res = T.unsafe(nil)); end

  # What HTTP version the request was submitted with.
  #
  # source://roda//lib/roda/request.rb#140
  def http_version; end

  # Show information about current request, including request class,
  # request method and full path.
  #
  #   r.inspect
  #   # => '#<Roda::RodaRequest GET /foo/bar>'
  #
  # source://roda//lib/roda/request.rb#126
  def inspect; end

  # Does a terminal match on the current path, matching only if the arguments
  # have fully matched the path.  If it matches, the match block is
  # executed, and when the match block returns, the rack response is
  # returned.
  #
  #   r.remaining_path
  #   # => "/foo/bar"
  #
  #   r.is 'foo' do
  #     # does not match, as path isn't fully matched (/bar remaining)
  #   end
  #
  #   r.is 'foo/bar' do
  #     # matches as path is empty after matching
  #   end
  #
  # If no arguments are given, matches if the path is already fully matched.
  #
  #   r.on 'foo/bar' do
  #     r.is do
  #       # matches as path is already empty
  #     end
  #   end
  #
  # Note that this matches only if the path after matching the arguments
  # is empty, not if it still contains a trailing slash:
  #
  #   r.remaining_path
  #   # =>  "/foo/bar/"
  #
  #   r.is 'foo/bar' do
  #     # does not match, as path isn't fully matched (/ remaining)
  #   end
  #
  #   r.is 'foo/bar/' do
  #     # matches as path is empty after matching
  #   end
  #
  #   r.on 'foo/bar' do
  #     r.is "" do
  #       # matches as path is empty after matching
  #     end
  #   end
  #
  # source://roda//lib/roda/request.rb#192
  def is(*args, &block); end

  # Optimized method for whether this request is a +GET+ request.
  # Similar to the default Rack::Request get? method, but can be
  # overridden without changing rack's behavior.
  #
  # @return [Boolean]
  #
  # source://roda//lib/roda/request.rb#206
  def is_get?; end

  # The already matched part of the path, including the original SCRIPT_NAME.
  #
  # source://roda//lib/roda/request.rb#246
  def matched_path; end

  # Does a match on the path, matching only if the arguments
  # have matched the path.  Because this doesn't fully match the
  # path, this is usually used to setup branches of the routing tree,
  # not for final handling of the request.
  #
  #   r.remaining_path
  #   # => "/foo/bar"
  #
  #   r.on 'foo' do
  #     # matches, path is /bar after matching
  #   end
  #
  #   r.on 'bar' do
  #     # does not match
  #   end
  #
  # Like other routing methods, If it matches, the match block is
  # executed, and when the match block returns, the rack response is
  # returned.  However, in general you will call another routing method
  # inside the match block that fully matches the path and does the
  # final handling for the request:
  #
  #   r.on 'foo' do
  #     r.is 'bar' do
  #       # handle /foo/bar request
  #     end
  #   end
  #
  # source://roda//lib/roda/request.rb#237
  def on(*args, &block); end

  # This an an optimized version of Rack::Request#path.
  #
  #   r.env['SCRIPT_NAME'] = '/foo'
  #   r.env['PATH_INFO'] = '/bar'
  #   r.path
  #   # => '/foo/bar'
  #
  # source://roda//lib/roda/request.rb#257
  def path; end

  # Match POST requests.  If no arguments are provided, matches all POST
  # requests, otherwise, matches only POST requests where the arguments
  # given fully consume the path.
  #
  # source://roda//lib/roda/request.rb#272
  def post(*args, &block); end

  # The current path to match requests against.
  # An alias of remaining_path. If a plugin changes remaining_path then
  # it should override this method to return the untouched original.
  def real_remaining_path; end

  # Immediately redirect to the path using the status code.  This ends
  # the processing of the request:
  #
  #   r.redirect '/page1', 301 if r['param'] == 'value1'
  #   r.redirect '/page2' # uses 302 status code
  #   response.status = 404 # not reached
  #
  # If you do not provide a path, by default it will redirect to the same
  # path if the request is not a +GET+ request.  This is designed to make
  # it easy to use where a +POST+ request to a URL changes state, +GET+
  # returns the current state, and you want to show the current state
  # after changing:
  #
  #   r.is "foo" do
  #     r.get do
  #       # show state
  #     end
  #
  #     r.post do
  #       # change state
  #       r.redirect
  #     end
  #   end
  #
  # source://roda//lib/roda/request.rb#299
  def redirect(path = T.unsafe(nil), status = T.unsafe(nil)); end

  # The current path to match requests against.
  #
  # source://roda//lib/roda/request.rb#263
  def remaining_path; end

  # The response related to the current request.  See ResponseMethods for
  # instance methods for the response, but in general the most common usage
  # is to override the response status and headers:
  #
  #   response.status = 200
  #   response['Header-Name'] = 'Header value'
  #
  # source://roda//lib/roda/request.rb#310
  def response; end

  # Return the Roda class related to this request.
  #
  # source://roda//lib/roda/request.rb#315
  def roda_class; end

  # Match method that only matches +GET+ requests where the current
  # path is +/+.  If it matches, the match block is executed, and when
  # the match block returns, the rack response is returned.
  #
  #   [r.request_method, r.remaining_path]
  #   # => ['GET', '/']
  #
  #   r.root do
  #     # matches
  #   end
  #
  # This is usuable inside other match blocks:
  #
  #   [r.request_method, r.remaining_path]
  #   # => ['GET', '/foo/']
  #
  #   r.on 'foo' do
  #     r.root do
  #       # matches
  #     end
  #   end
  #
  # Note that this does not match non-+GET+ requests:
  #
  #   [r.request_method, r.remaining_path]
  #   # => ['POST', '/']
  #
  #   r.root do
  #     # does not match
  #   end
  #
  # Use <tt>r.post ""</tt> for +POST+ requests where the current path
  # is +/+.
  #
  # Nor does it match empty paths:
  #
  #   [r.request_method, r.remaining_path]
  #   # => ['GET', '/foo']
  #
  #   r.on 'foo' do
  #     r.root do
  #       # does not match
  #     end
  #   end
  #
  # Use <tt>r.get true</tt> to handle +GET+ requests where the current
  # path is empty.
  #
  # source://roda//lib/roda/request.rb#366
  def root(&block); end

  # Call the given rack app with the environment and return the response
  # from the rack app as the response for this request.  This ends
  # the processing of the request:
  #
  #   r.run(proc{[403, {}, []]}) unless r['letmein'] == '1'
  #   r.run(proc{[404, {}, []]})
  #   response.status = 404 # not reached
  #
  # This updates SCRIPT_NAME/PATH_INFO based on the current remaining_path
  # before dispatching to another rack app, so the app still works as
  # a URL mapper.
  #
  # source://roda//lib/roda/request.rb#383
  def run(app); end

  # The Roda instance related to this request object.  Useful if routing
  # methods need access to the scope of the Roda route block.
  #
  # source://roda//lib/roda/request.rb#81
  def scope; end

  # The session for the current request.  Raises a RodaError if
  # a session handler has not been loaded.
  #
  # source://roda//lib/roda/request.rb#402
  def session; end

  private

  # Match any of the elements in the given array.  Return at the
  # first match without evaluating future matches.  Returns false
  # if no elements in the array match.
  #
  # source://roda//lib/roda/request.rb#411
  def _match_array(matcher); end

  # Match the given class.  Currently, the following classes
  # are supported by default:
  # Integer :: Match an integer segment, yielding result to block as an integer
  # String :: Match any non-empty segment, yielding result to block as a string
  #
  # source://roda//lib/roda/request.rb#427
  def _match_class(klass); end

  # Match integer segment of up to 100 decimal characters, and yield resulting value as an
  # integer.
  #
  # source://roda//lib/roda/request.rb#445
  def _match_class_Integer; end

  # Match the given symbol if any segment matches.
  # Match any nonempty segment.  This should be called without an argument.
  #
  # source://roda//lib/roda/request.rb#502
  def _match_class_String(sym = T.unsafe(nil)); end

  # Convert the segment matched by the Integer matcher to an integer.
  #
  # source://roda//lib/roda/request.rb#454
  def _match_class_convert_Integer(value); end

  # Match the given hash if all hash matchers match.
  #
  # source://roda//lib/roda/request.rb#438
  def _match_hash(hash); end

  # Match only if all of the arguments in the given array match.
  # Match the given regexp exactly if it matches a full segment.
  #
  # source://roda//lib/roda/request.rb#460
  def _match_regexp(re); end

  # Match the given string to the request path.  Matches only if the
  # request path ends with the string or if the next character in the
  # request path is a slash (indicating a new segment).
  #
  # source://roda//lib/roda/request.rb#467
  def _match_string(str); end

  # Match the given symbol if any segment matches.
  #
  # source://roda//lib/roda/request.rb#502
  def _match_symbol(sym = T.unsafe(nil)); end

  # The base remaining path to use.
  #
  # source://roda//lib/roda/request.rb#519
  def _remaining_path(env); end

  # Backbone of the verb method support, using a terminal match if
  # args is not empty, or a regular match if it is empty.
  #
  # source://roda//lib/roda/request.rb#525
  def _verb(args, &block); end

  # Yield to the match block and return rack response after the block returns.
  #
  # source://roda//lib/roda/request.rb#535
  def always; end

  # The body to use for the response if the response does not already have
  # a body.  By default, a String is returned directly, and nil is
  # returned otherwise.
  #
  # source://roda//lib/roda/request.rb#543
  def block_result_body(result); end

  # Attempts to match the pattern to the current path.  If there is no
  # match, returns false without changes.  Otherwise, modifies
  # SCRIPT_NAME to include the matched path, removes the matched
  # path from PATH_INFO, and updates captures with any regex captures.
  #
  # source://roda//lib/roda/request.rb#558
  def consume(pattern); end

  # The default path to use for redirects when a path is not given.
  # For non-GET requests, redirects to the current path, which will
  # trigger a GET request.  This is to make the common case where
  # a POST request will redirect to a GET request at the same location
  # will work fine.
  #
  # If the current request is a GET request, raise an error, as otherwise
  # it is easy to create an infinite redirect.
  #
  # @raise [RodaError]
  #
  # source://roda//lib/roda/request.rb#577
  def default_redirect_path; end

  # The default status to use for redirects if a status is not provided,
  # 302 by default.
  #
  # source://roda//lib/roda/request.rb#584
  def default_redirect_status; end

  # Whether the current path is considered empty.
  #
  # @return [Boolean]
  #
  # source://roda//lib/roda/request.rb#589
  def empty_path?; end

  # If all of the arguments match, yields to the match block and
  # returns the rack response when the block returns.  If any of
  # the match arguments doesn't match, does nothing.
  #
  # source://roda//lib/roda/request.rb#596
  def if_match(args); end

  # Attempt to match the argument to the given request, handling
  # common ruby types.
  #
  # source://roda//lib/roda/request.rb#613
  def match(matcher); end

  # Match only if all of the arguments in the given array match.
  #
  # source://roda//lib/roda/request.rb#641
  def match_all(args); end

  # Match by request method.  This can be an array if you want
  # to match on multiple methods.
  #
  # source://roda//lib/roda/request.rb#647
  def match_method(type); end

  # How to handle block results that are not nil, false, or a String.
  # By default raises an exception.
  #
  # @raise [RodaError]
  #
  # source://roda//lib/roda/request.rb#657
  def unsupported_block_result(result); end

  # Handle an unsupported matcher.
  #
  # @raise [RodaError]
  #
  # source://roda//lib/roda/request.rb#662
  def unsupported_matcher(matcher); end
end

# source://roda//lib/roda/request.rb#69
Roda::RodaPlugins::Base::RequestMethods::TERM = T.let(T.unsafe(nil), Object)

# Class methods for RodaResponse
#
# source://roda//lib/roda/response.rb#35
module Roda::RodaPlugins::Base::ResponseClassMethods
  # Since RodaResponse is anonymously subclassed when Roda is subclassed,
  # and then assigned to a constant of the Roda subclass, make inspect
  # reflect the likely name for the class.
  #
  # source://roda//lib/roda/response.rb#42
  def inspect; end

  # Reference to the Roda class related to this response class.
  #
  # source://roda//lib/roda/response.rb#37
  def roda_class; end

  # Reference to the Roda class related to this response class.
  #
  # source://roda//lib/roda/response.rb#37
  def roda_class=(_arg0); end
end

# Instance methods for RodaResponse
#
# source://roda//lib/roda/response.rb#48
module Roda::RodaPlugins::Base::ResponseMethods
  # Set the default headers when creating a response.
  #
  # source://roda//lib/roda/response.rb#62
  def initialize; end

  # Return the response header with the given key. Example:
  #
  #   response['Content-Type'] # => 'text/html'
  #
  # source://roda//lib/roda/response.rb#71
  def [](key); end

  # Set the response header with the given key to the given value.
  #
  #   response['Content-Type'] = 'application/json'
  #
  # source://roda//lib/roda/response.rb#78
  def []=(key, value); end

  # The body for the current response.
  #
  # source://roda//lib/roda/response.rb#52
  def body; end

  # The default headers to use for responses.
  #
  # source://roda//lib/roda/response.rb#83
  def default_headers; end

  # Return the default response status to be used when the body
  # has been written to. This is split out to make overriding
  # easier in plugins.
  #
  # source://roda//lib/roda/response.rb#144
  def default_status; end

  # Whether the response body has been written to yet.  Note
  # that writing an empty string to the response body marks
  # the response as not empty. Example:
  #
  #   response.empty? # => true
  #   response.write('a')
  #   response.empty? # => false
  #
  # @return [Boolean]
  #
  # source://roda//lib/roda/response.rb#94
  def empty?; end

  # Return the rack response array of status, headers, and body
  # for the current response.  If the status has not been set,
  # uses the return value of default_status if the body has
  # been written to, otherwise uses a 404 status.
  # Adds the Content-Length header to the size of the response body.
  #
  # Example:
  #
  #   response.finish
  #   #  => [200,
  #   #      {'Content-Type'=>'text/html', 'Content-Length'=>'0'},
  #   #      []]
  #
  # source://roda//lib/roda/response.rb#110
  def finish; end

  # Return the rack response array using a given body.  Assumes a
  # 200 response status unless status has been explicitly set,
  # and doesn't add the Content-Length header or use the existing
  # body.
  #
  # source://roda//lib/roda/response.rb#136
  def finish_with_body(body); end

  # The hash of response headers for the current response.
  #
  # source://roda//lib/roda/response.rb#55
  def headers; end

  # Show response class, status code, response headers, and response body
  #
  # source://roda//lib/roda/response.rb#149
  def inspect; end

  # Set the Location header to the given path, and the status
  # to the given status.  Example:
  #
  #   response.redirect('foo', 301)
  #   response.redirect('bar')
  #
  # source://roda//lib/roda/response.rb#158
  def redirect(path, status = T.unsafe(nil)); end

  # Return the Roda class related to this response.
  #
  # source://roda//lib/roda/response.rb#165
  def roda_class; end

  # The status code to use for the response.  If none is given, will use 200
  # code for non-empty responses and a 404 code for empty responses.
  #
  # source://roda//lib/roda/response.rb#59
  def status; end

  # The status code to use for the response.  If none is given, will use 200
  # code for non-empty responses and a 404 code for empty responses.
  #
  # source://roda//lib/roda/response.rb#59
  def status=(_arg0); end

  # Write to the response body.  Returns nil.
  #
  #   response.write('foo')
  #
  # source://roda//lib/roda/response.rb#172
  def write(str); end

  private

  # Use plain hash for headers by default on Rack 1-2
  #
  # source://roda//lib/roda/response.rb#188
  def _initialize_headers; end

  # Set the content length for empty 205 responses to 0
  #
  # source://roda//lib/roda/response.rb#202
  def empty_205_headers(headers); end

  # For each default header, if a header has not already been set for the
  # response, set the header in the response.
  #
  # source://roda//lib/roda/response.rb#210
  def set_default_headers; end
end

# source://roda//lib/roda/response.rb#49
Roda::RodaPlugins::Base::ResponseMethods::DEFAULT_HEADERS = T.let(T.unsafe(nil), Hash)

# Internal before hook module, not for external use.
# Allows for plugins to configure the order in which
# before processing is done by using _roda_before_*
# private instance methods that are called in sorted order.
# Loaded automatically by the base library if any _roda_before_*
# methods are defined.
#
# source://roda//lib/roda/plugins/_before_hook.rb#12
module Roda::RodaPlugins::BeforeHook; end

# source://roda//lib/roda/plugins/_before_hook.rb#13
module Roda::RodaPlugins::BeforeHook::InstanceMethods
  # Run internal before hooks before running the main
  # roda route.
  #
  # source://roda//lib/roda/plugins/_before_hook.rb#25
  def _roda_run_main_route(r); end

  # Run internal before hooks - Old Dispatch API.
  #
  # source://roda//lib/roda/plugins/_before_hook.rb#15
  def call(&block); end

  private

  # Default empty implementation of _roda_before, usually
  # overridden by Roda.def_roda_before.
  #
  # source://roda//lib/roda/plugins/_before_hook.rb#34
  def _roda_before; end
end

# The class_matchers plugin allows you do define custom regexps and
# conversion procs to use for specific classes.  For example, if you
# have multiple routes similar to:
#
#   r.on /(\d\d\d\d)-(\d\d)-(\d\d)/ do |y, m, d|
#     date = Date.new(y.to_i, m.to_i, d.to_i)
#     # ...
#   end
#
# You can register a Date class matcher for that regexp (note that
# the block must return an array):
#
#   class_matcher(Date, /(\d\d\d\d)-(\d\d)-(\d\d)/) do |y, m, d|
#     [Date.new(y.to_i, m.to_i, d.to_i)]
#   end
#
# And then use the Date class as a matcher, and it will yield a Date object:
#
#   r.on Date do |date|
#     # ...
#   end
#
# This is useful to DRY up code if you are using the same type of pattern and
# type conversion in multiple places in your application.
#
# If you have a segment match the passed regexp, but decide during block
# processing that you do not want to treat it as a match, you can have the
# block return nil or false.  This is useful if you want to make sure you
# are using valid data:
#
#   class_matcher(Date, /(\d\d\d\d)-(\d\d)-(\d\d)/) do |y, m, d|
#     y = y.to_i
#     m = m.to_i
#     d = d.to_i
#     [Date.new(y, m, d)] if Date.valid_date?(y, m, d)
#   end
#
# This plugin does not work with the params_capturing plugin, as it does not
# offer the ability to associate block arguments with named keys.
#
# source://roda//lib/roda/plugins/class_matchers.rb#45
module Roda::RodaPlugins::ClassMatchers; end

# source://roda//lib/roda/plugins/class_matchers.rb#46
module Roda::RodaPlugins::ClassMatchers::ClassMethods
  # Set the regexp to use for the given class.  The block given will be
  # called with all matched values from the regexp, and should return an
  # array with the captures to yield to the match block.
  #
  # source://roda//lib/roda/plugins/class_matchers.rb#50
  def class_matcher(klass, re, &block); end
end

# The content_security_policy plugin allows you to easily set a Content-Security-Policy
# header for the application, which modern browsers will use to control access to specific
# types of page content.
#
# You would generally call the plugin with a block to set the default policy:
#
#   plugin :content_security_policy do |csp|
#     csp.default_src :none
#     csp.img_src :self
#     csp.style_src :self
#     csp.script_src :self
#     csp.font_src :self
#     csp.form_action :self
#     csp.base_uri :none
#     csp.frame_ancestors :none
#     csp.block_all_mixed_content
#   end
#
# Then, anywhere in the routing tree, you can customize the policy for just that
# branch or action using the same block syntax:
#
#   r.get 'foo' do
#     content_security_policy do |csp|
#       csp.object_src :self
#       csp.add_style_src 'bar.com'
#     end
#     # ...
#   end
#
# In addition to using a block, you can also call methods on the object returned
# by the method:
#
#   r.get 'foo' do
#     content_security_policy.script_src :self, 'example.com', [:nonce, 'foobarbaz']
#     # ...
#   end
#
# The following methods are available for configuring the content security policy,
# which specify the setting (substituting _ with -):
#
# * base_uri
# * child_src
# * connect_src
# * default_src
# * font_src
# * form_action
# * frame_ancestors
# * frame_src
# * img_src
# * manifest_src
# * media_src
# * object_src
# * plugin_types
# * report_to
# * report_uri
# * require_sri_for
# * sandbox
# * script_src
# * style_src
# * worker_src
#
# All of these methods support any number of arguments, and each argument should
# be one of the following types:
#
# String :: used verbatim
# Symbol :: Substitutes +_+ with +-+ and surrounds with <tt>'</tt>
# Array :: only accepts 2 element arrays, joins elements with +-+ and
#          surrounds the result with <tt>'</tt>
#
# Example:
#
#   content_security_policy.script_src :self, :unsafe_eval, 'example.com', [:nonce, 'foobarbaz']
#   # script-src 'self' 'unsafe-eval' example.com 'nonce-foobarbaz';
#
# When calling a method with no arguments, the setting is removed from the policy instead
# of being left empty, since all of these setting require at least one value.  Likewise,
# if the policy does not have any settings, the header will not be added.
#
# Calling the method overrides any previous setting.  Each of the methods has +add_*+ and
# +get_*+ methods defined. The +add_*+ method appends to any existing setting, and the +get_*+ method
# returns the current value for the setting.
#
#   content_security_policy.script_src :self, :unsafe_eval
#   content_security_policy.add_script_src 'example.com', [:nonce, 'foobarbaz']
#   # script-src 'self' 'unsafe-eval' example.com 'nonce-foobarbaz';
#
#   content_security_policy.get_script_src
#   # => [:self, :unsafe_eval, 'example.com', [:nonce, 'foobarbaz']]
#
# The clear method can be used to remove all settings from the policy.
#
# The following methods to set boolean settings are also defined:
#
# * block_all_mixed_content
# * upgrade_insecure_requests
#
# Calling these methods will turn on the related setting.  To turn the setting
# off again, you can call them with a +false+ argument. There is also a <tt>*?</tt> method
# for each setting for returning whether the setting is currently enabled.
#
# Likewise there is also a +report_only+ method for turning on report only mode (the
# default is enforcement mode), or turning off report only mode if a false argument
# is given.  Also, there is a +report_only?+ method for returning whether report only
# mode is enabled.
#
# source://roda//lib/roda/plugins/content_security_policy.rb#110
module Roda::RodaPlugins::ContentSecurityPolicy
  class << self
    # Yield the current Content Security Policy to the block.
    #
    # @yield [policy]
    #
    # source://roda//lib/roda/plugins/content_security_policy.rb#274
    def configure(app); end
  end
end

# source://roda//lib/roda/plugins/content_security_policy.rb#285
module Roda::RodaPlugins::ContentSecurityPolicy::InstanceMethods
  # If a block is given, yield the current content security policy.  Returns the
  # current content security policy.
  #
  # @yield [policy]
  #
  # source://roda//lib/roda/plugins/content_security_policy.rb#288
  def content_security_policy; end
end

# Represents a content security policy.
#
# source://roda//lib/roda/plugins/content_security_policy.rb#112
class Roda::RodaPlugins::ContentSecurityPolicy::Policy
  # @return [Policy] a new instance of Policy
  #
  # source://roda//lib/roda/plugins/content_security_policy.rb#185
  def initialize; end

  # source://roda//lib/roda/plugins/content_security_policy.rb#149
  def add_base_uri(*args); end

  # source://roda//lib/roda/plugins/content_security_policy.rb#149
  def add_child_src(*args); end

  # source://roda//lib/roda/plugins/content_security_policy.rb#149
  def add_connect_src(*args); end

  # source://roda//lib/roda/plugins/content_security_policy.rb#149
  def add_default_src(*args); end

  # source://roda//lib/roda/plugins/content_security_policy.rb#149
  def add_font_src(*args); end

  # source://roda//lib/roda/plugins/content_security_policy.rb#149
  def add_form_action(*args); end

  # source://roda//lib/roda/plugins/content_security_policy.rb#149
  def add_frame_ancestors(*args); end

  # source://roda//lib/roda/plugins/content_security_policy.rb#149
  def add_frame_src(*args); end

  # source://roda//lib/roda/plugins/content_security_policy.rb#149
  def add_img_src(*args); end

  # source://roda//lib/roda/plugins/content_security_policy.rb#149
  def add_manifest_src(*args); end

  # source://roda//lib/roda/plugins/content_security_policy.rb#149
  def add_media_src(*args); end

  # source://roda//lib/roda/plugins/content_security_policy.rb#149
  def add_object_src(*args); end

  # source://roda//lib/roda/plugins/content_security_policy.rb#149
  def add_plugin_types(*args); end

  # source://roda//lib/roda/plugins/content_security_policy.rb#149
  def add_report_to(*args); end

  # source://roda//lib/roda/plugins/content_security_policy.rb#149
  def add_report_uri(*args); end

  # source://roda//lib/roda/plugins/content_security_policy.rb#149
  def add_require_sri_for(*args); end

  # source://roda//lib/roda/plugins/content_security_policy.rb#149
  def add_sandbox(*args); end

  # source://roda//lib/roda/plugins/content_security_policy.rb#149
  def add_script_src(*args); end

  # source://roda//lib/roda/plugins/content_security_policy.rb#149
  def add_style_src(*args); end

  # source://roda//lib/roda/plugins/content_security_policy.rb#149
  def add_worker_src(*args); end

  # source://roda//lib/roda/plugins/content_security_policy.rb#138
  def base_uri(*args); end

  # source://roda//lib/roda/plugins/content_security_policy.rb#169
  def block_all_mixed_content(arg = T.unsafe(nil)); end

  # source://roda//lib/roda/plugins/content_security_policy.rb#180
  def block_all_mixed_content?; end

  # source://roda//lib/roda/plugins/content_security_policy.rb#138
  def child_src(*args); end

  # Clear all settings, useful to remove any inherited settings.
  #
  # source://roda//lib/roda/plugins/content_security_policy.rb#190
  def clear; end

  # source://roda//lib/roda/plugins/content_security_policy.rb#138
  def connect_src(*args); end

  # source://roda//lib/roda/plugins/content_security_policy.rb#138
  def default_src(*args); end

  # source://roda//lib/roda/plugins/content_security_policy.rb#138
  def font_src(*args); end

  # source://roda//lib/roda/plugins/content_security_policy.rb#138
  def form_action(*args); end

  # source://roda//lib/roda/plugins/content_security_policy.rb#138
  def frame_ancestors(*args); end

  # source://roda//lib/roda/plugins/content_security_policy.rb#138
  def frame_src(*args); end

  # Do not allow future modifications to any settings.
  #
  # source://roda//lib/roda/plugins/content_security_policy.rb#195
  def freeze; end

  # source://roda//lib/roda/plugins/content_security_policy.rb#159
  def get_base_uri; end

  # source://roda//lib/roda/plugins/content_security_policy.rb#159
  def get_child_src; end

  # source://roda//lib/roda/plugins/content_security_policy.rb#159
  def get_connect_src; end

  # source://roda//lib/roda/plugins/content_security_policy.rb#159
  def get_default_src; end

  # source://roda//lib/roda/plugins/content_security_policy.rb#159
  def get_font_src; end

  # source://roda//lib/roda/plugins/content_security_policy.rb#159
  def get_form_action; end

  # source://roda//lib/roda/plugins/content_security_policy.rb#159
  def get_frame_ancestors; end

  # source://roda//lib/roda/plugins/content_security_policy.rb#159
  def get_frame_src; end

  # source://roda//lib/roda/plugins/content_security_policy.rb#159
  def get_img_src; end

  # source://roda//lib/roda/plugins/content_security_policy.rb#159
  def get_manifest_src; end

  # source://roda//lib/roda/plugins/content_security_policy.rb#159
  def get_media_src; end

  # source://roda//lib/roda/plugins/content_security_policy.rb#159
  def get_object_src; end

  # source://roda//lib/roda/plugins/content_security_policy.rb#159
  def get_plugin_types; end

  # source://roda//lib/roda/plugins/content_security_policy.rb#159
  def get_report_to; end

  # source://roda//lib/roda/plugins/content_security_policy.rb#159
  def get_report_uri; end

  # source://roda//lib/roda/plugins/content_security_policy.rb#159
  def get_require_sri_for; end

  # source://roda//lib/roda/plugins/content_security_policy.rb#159
  def get_sandbox; end

  # source://roda//lib/roda/plugins/content_security_policy.rb#159
  def get_script_src; end

  # source://roda//lib/roda/plugins/content_security_policy.rb#159
  def get_style_src; end

  # source://roda//lib/roda/plugins/content_security_policy.rb#159
  def get_worker_src; end

  # The header name to use, depends on whether report only mode has been enabled.
  #
  # source://roda//lib/roda/plugins/content_security_policy.rb#202
  def header_key; end

  # The header value to use.
  #
  # source://roda//lib/roda/plugins/content_security_policy.rb#207
  def header_value; end

  # source://roda//lib/roda/plugins/content_security_policy.rb#138
  def img_src(*args); end

  # source://roda//lib/roda/plugins/content_security_policy.rb#138
  def manifest_src(*args); end

  # source://roda//lib/roda/plugins/content_security_policy.rb#138
  def media_src(*args); end

  # source://roda//lib/roda/plugins/content_security_policy.rb#138
  def object_src(*args); end

  # source://roda//lib/roda/plugins/content_security_policy.rb#138
  def plugin_types(*args); end

  # Set whether the Content-Security-Policy-Report-Only header instead of the
  # default Content-Security-Policy header.
  #
  # source://roda//lib/roda/plugins/content_security_policy.rb#223
  def report_only(report = T.unsafe(nil)); end

  # Whether this policy uses report only mode.
  #
  # @return [Boolean]
  #
  # source://roda//lib/roda/plugins/content_security_policy.rb#228
  def report_only?; end

  # source://roda//lib/roda/plugins/content_security_policy.rb#138
  def report_to(*args); end

  # source://roda//lib/roda/plugins/content_security_policy.rb#138
  def report_uri(*args); end

  # source://roda//lib/roda/plugins/content_security_policy.rb#138
  def require_sri_for(*args); end

  # source://roda//lib/roda/plugins/content_security_policy.rb#138
  def sandbox(*args); end

  # source://roda//lib/roda/plugins/content_security_policy.rb#138
  def script_src(*args); end

  # Set the current policy in the headers hash.  If no settings have been made
  # in the policy, does not set a header.
  #
  # source://roda//lib/roda/plugins/content_security_policy.rb#234
  def set_header(headers); end

  # source://roda//lib/roda/plugins/content_security_policy.rb#138
  def style_src(*args); end

  # source://roda//lib/roda/plugins/content_security_policy.rb#169
  def upgrade_insecure_requests(arg = T.unsafe(nil)); end

  # source://roda//lib/roda/plugins/content_security_policy.rb#180
  def upgrade_insecure_requests?; end

  # source://roda//lib/roda/plugins/content_security_policy.rb#138
  def worker_src(*args); end

  private

  # Handle three types of values when formatting the header:
  # String :: used verbatim
  # Symbol :: Substitutes _ with - and surrounds with '
  # Array :: only accepts 2 element arrays, joins them with - and
  #          surrounds them with '
  #
  # source://roda//lib/roda/plugins/content_security_policy.rb#246
  def append_formatted_value(s, v); end

  # Make object copy use copy of settings, and remove cached header value.
  #
  # source://roda//lib/roda/plugins/content_security_policy.rb#265
  def initialize_copy(_); end
end

# source://roda//lib/roda/plugins/content_security_policy.rb#295
module Roda::RodaPlugins::ContentSecurityPolicy::ResponseMethods
  # Unset any content security policy when reinitializing
  #
  # source://roda//lib/roda/plugins/content_security_policy.rb#297
  def initialize; end

  # The current content security policy to be used for this response.
  #
  # source://roda//lib/roda/plugins/content_security_policy.rb#303
  def content_security_policy; end

  private

  # Set the appropriate content security policy header.
  #
  # source://roda//lib/roda/plugins/content_security_policy.rb#310
  def set_default_headers; end
end

# The custom_block_results plugin allows you to specify handling
# for different block results.  By default, Roda only supports
# nil, false, and string block results, but using this plugin,
# you can support other block results.
#
# For example, if you wanted to support returning Integer
# block results, and have them set the response status code,
# you could do:
#
#   plugin :custom_block_results
#
#   handle_block_result Integer do |result|
#     response.status_code = result
#   end
#
#   route do |r|
#     200
#   end
#
# The expected use case for this is to customize behavior by
# class, but matching uses ===, so it is possible to use non-class
# objects that respond to === appropriately.
#
# Note that custom block result handling only occurs if the types
# are not handled by Roda itself.  You cannot use this to modify
# the handling of nil, false, or string results.
#
# source://roda//lib/roda/plugins/custom_block_results.rb#32
module Roda::RodaPlugins::CustomBlockResults
  class << self
    # source://roda//lib/roda/plugins/custom_block_results.rb#33
    def configure(app); end
  end
end

# source://roda//lib/roda/plugins/custom_block_results.rb#37
module Roda::RodaPlugins::CustomBlockResults::ClassMethods
  # Freeze the configured custom block results when freezing the app.
  #
  # source://roda//lib/roda/plugins/custom_block_results.rb#39
  def freeze; end

  # Specify a block that will be called when an instance of klass
  # is returned as a block result.  The block defines a method.
  #
  # source://roda//lib/roda/plugins/custom_block_results.rb#46
  def handle_block_result(klass, &block); end
end

# source://roda//lib/roda/plugins/custom_block_results.rb#51
module Roda::RodaPlugins::CustomBlockResults::RequestMethods
  private

  # Try each configured custom block result, and call the related method
  # to get the block result.
  #
  # source://roda//lib/roda/plugins/custom_block_results.rb#56
  def unsupported_block_result(result); end
end

# source://roda//lib/roda/plugins.rb#10
Roda::RodaPlugins::EMPTY_ARRAY = T.let(T.unsafe(nil), Array)

# The error_handler plugin adds an error handler to the routing,
# so that if routing the request raises an error, a nice error
# message page can be returned to the user.
#
# You can provide the error handler as a block to the plugin:
#
#   plugin :error_handler do |e|
#     "Oh No!"
#   end
#
# Or later via the +error+ class method:
#
#   plugin :error_handler
#
#   error do |e|
#     "Oh No!"
#   end
#
# In both cases, the exception instance is passed into the block,
# and the block can return the request body via a string.
#
# If an exception is raised, a new response will be used, with the
# default status set to 500, before executing the error handler.
# The error handler can change the response status if necessary,
# as well set headers and/or write to the body, just like a regular
# request.  After the error handler returns a response, normal after
# processing of that response occurs, except that an exception during
# after processing is logged to <tt>env['rack.errors']</tt> but
# otherwise ignored. This avoids recursive calls into the
# error_handler.  Note that if the error_handler itself raises
# an exception, the exception will be raised without normal after
# processing.  This can cause some after processing to run twice
# (once before the error_handler is called and once after) if
# later after processing raises an exception.
#
# By default, this plugin handles StandardError and ScriptError.
# To override the exception classes it will handle, pass a :classes
# option to the plugin:
#
#   plugin :error_handler, classes: [StandardError, ScriptError, NoMemoryError]
#
# source://roda//lib/roda/plugins/error_handler.rb#46
module Roda::RodaPlugins::ErrorHandler
  class << self
    # If a block is given, automatically call the +error+ method on
    # the Roda class with it.
    #
    # source://roda//lib/roda/plugins/error_handler.rb#51
    def configure(app, opts = T.unsafe(nil), &block); end
  end
end

# source://roda//lib/roda/plugins/error_handler.rb#59
module Roda::RodaPlugins::ErrorHandler::ClassMethods
  # Install the given block as the error handler, so that if routing
  # the request raises an exception, the block will be called with
  # the exception in the scope of the Roda instance.
  #
  # source://roda//lib/roda/plugins/error_handler.rb#63
  def error(&block); end
end

# source://roda//lib/roda/plugins/error_handler.rb#47
Roda::RodaPlugins::ErrorHandler::DEFAULT_ERROR_HANDLER_CLASSES = T.let(T.unsafe(nil), Array)

# source://roda//lib/roda/plugins/error_handler.rb#70
module Roda::RodaPlugins::ErrorHandler::InstanceMethods
  # If an error occurs, set the response status to 500 and call
  # the error handler.
  #
  # source://roda//lib/roda/plugins/error_handler.rb#86
  def _roda_handle_main_route; end

  # If an error occurs, set the response status to 500 and call
  # the error handler. Old Dispatch API.
  #
  # source://roda//lib/roda/plugins/error_handler.rb#73
  def call; end

  private

  # Handle the given exception using handle_error, using a default status
  # of 500.  Run after hooks on the rack response, but if any error occurs
  # when doing so, log the error using rack.errors and return the response.
  #
  # source://roda//lib/roda/plugins/error_handler.rb#106
  def _handle_error(e); end

  # Default empty implementation of _roda_after, usually
  # overridden by Roda.def_roda_before.
  #
  # source://roda//lib/roda/plugins/error_handler.rb#100
  def _roda_after(res); end

  # By default, have the error handler reraise the error, so using
  # the plugin without installing an error handler doesn't change
  # behavior.
  #
  # source://roda//lib/roda/plugins/error_handler.rb#125
  def handle_error(e); end
end

# The flash plugin adds a +flash+ instance method to Roda,
# for typical web application flash handling, where values
# set in the current flash hash are available in the next
# request.
#
# With the example below, if a POST request is submitted,
# it will redirect and the resulting GET request will
# return 'b'.
#
#   plugin :flash
#
#   route do |r|
#     r.is '' do
#       r.get do
#         flash['a']
#       end
#
#       r.post do
#         flash['a'] = 'b'
#         r.redirect('')
#       end
#     end
#   end
#
# You can modify the flash for the current request (instead of
# the next request) by using the +flash.now+ method:
#
#   r.get do
#     flash.now['a'] = 'b'
#     flash['a'] # = >'b'
#   end
#
# source://roda//lib/roda/plugins/flash.rb#38
module Roda::RodaPlugins::Flash; end

# Simple flash hash, where assiging to the hash updates the flash
# used in the following request.
#
# source://roda//lib/roda/plugins/flash.rb#41
class Roda::RodaPlugins::Flash::FlashHash
  # Setup the next hash when initializing, and handle treat nil
  # as a new empty hash.
  #
  # @return [FlashHash] a new instance of FlashHash
  #
  # source://roda//lib/roda/plugins/flash.rb#51
  def initialize(hash = T.unsafe(nil)); end

  # Update the next hash with the given key and value.
  #
  # source://roda//lib/roda/plugins/flash.rb#57
  def []=(k, v); end

  # Remove given key from the next hash, or clear the next hash if
  # no argument is given.
  #
  # source://roda//lib/roda/plugins/flash.rb#63
  def discard(key = T.unsafe(nil)); end

  # Copy the entry with the given key from the current hash to the
  # next hash, or copy all entries from the current hash to the
  # next hash if no argument is given.
  #
  # source://roda//lib/roda/plugins/flash.rb#74
  def keep(key = T.unsafe(nil)); end

  # The flash hash for the next request.  This
  # is what gets written to by #[]=.
  #
  # source://roda//lib/roda/plugins/flash.rb#44
  def next; end

  # The flash hash for the current request
  #
  # source://delegate/0.3.0/delegate.rb#402
  def now; end

  # Replace the current hash with the next hash and clear the next hash.
  #
  # source://roda//lib/roda/plugins/flash.rb#83
  def sweep; end
end

# source://roda//lib/roda/plugins/flash.rb#90
module Roda::RodaPlugins::Flash::InstanceMethods
  # Access the flash hash for the current request, loading
  # it from the session if it is not already loaded.
  #
  # source://roda//lib/roda/plugins/flash.rb#93
  def flash; end

  private

  # If the routing doesn't raise an error, rotate the flash
  # hash in the session so the next request has access to it.
  #
  # source://roda//lib/roda/plugins/flash.rb#102
  def _roda_after_40__flash(_); end
end

# The hooks plugin adds before and after hooks to the request cycle.
#
#   plugin :hooks
#
#   before do
#     request.redirect('/login') unless logged_in?
#     @time = Time.now
#   end
#
#   after do |res|
#     logger.notice("Took #{Time.now - @time} seconds")
#   end
#
# Note that in general, before hooks are not needed, since you can just
# run code at the top of the route block:
#
#   route do |r|
#     r.redirect('/login') unless logged_in?
#     # ...
#   end
#
# However, this code makes it easier to write after hooks, as well as
# handle cases where before hooks are added after the route block.
#
# Note that the after hook is called with the rack response array
# of status, headers, and body.  If it wants to change the response,
# it must mutate this argument, calling <tt>response.status=</tt> inside
# an after block will not affect the returned status. Note that after
# hooks can be called with nil if an exception is raised during routing.
#
# source://roda//lib/roda/plugins/hooks.rb#35
module Roda::RodaPlugins::Hooks
  class << self
    # source://roda//lib/roda/plugins/hooks.rb#36
    def configure(app); end
  end
end

# source://roda//lib/roda/plugins/hooks.rb#41
module Roda::RodaPlugins::Hooks::ClassMethods
  # Add an after hook.
  #
  # source://roda//lib/roda/plugins/hooks.rb#51
  def after(&block); end

  # Add a before hook.
  #
  # source://roda//lib/roda/plugins/hooks.rb#64
  def before(&block); end

  # Freeze the array of hook methods when freezing the app.
  #
  # source://roda//lib/roda/plugins/hooks.rb#43
  def freeze; end
end

# source://roda//lib/roda/plugins/hooks.rb#77
module Roda::RodaPlugins::Hooks::InstanceMethods
  private

  # Default method if no after hooks are defined.
  #
  # source://roda//lib/roda/plugins/hooks.rb#81
  def _roda_after_80__hooks(res); end

  # Default method if no before hooks are defined.
  #
  # source://roda//lib/roda/plugins/hooks.rb#85
  def _roda_before_10__hooks; end
end

# The not_found plugin adds a +not_found+ class method which sets
# a block that is called whenever a 404 response with an empty body
# would be returned.  The usual use case for this is the desire for
# nice error pages if the page is not found.
#
# You can provide the block with the plugin call:
#
#   plugin :not_found do
#     "Where did it go?"
#   end
#
# Or later via a separate call to +not_found+:
#
#   plugin :not_found
#
#   not_found do
#     "Where did it go?"
#   end
#
# Before not_found is called, any existing headers on the response
# will be cleared.  So if you want to be sure the headers are set
# even in a not_found block, you need to reset them in the
# not_found block.
#
# This plugin is now a wrapper around the +status_handler+ plugin and
# still exists mainly for backward compatibility.
#
# source://roda//lib/roda/plugins/not_found.rb#32
module Roda::RodaPlugins::NotFound
  class << self
    # If a block is given, install the block as the not_found handler.
    #
    # source://roda//lib/roda/plugins/not_found.rb#39
    def configure(app, &block); end

    # Require the status_handler plugin
    #
    # source://roda//lib/roda/plugins/not_found.rb#34
    def load_dependencies(app); end
  end
end

# source://roda//lib/roda/plugins/not_found.rb#45
module Roda::RodaPlugins::NotFound::ClassMethods
  # Install the given block as the not_found handler.
  #
  # source://roda//lib/roda/plugins/not_found.rb#47
  def not_found(&block); end
end

# source://roda//lib/roda/plugins.rb#9
Roda::RodaPlugins::OPTS = T.let(T.unsafe(nil), Hash)

# The partials plugin adds a +partial+ method, which renders
# templates without the layout.
#
#   plugin :partials, views: 'path/2/views'
#
# Template files are prefixed with an underscore:
#
#   partial('test')     # uses _test.erb
#   partial('dir/test') # uses dir/_test.erb
#
# This is basically equivalent to:
#
#   render('_test')
#   render('dir/_test')
#
# To render the same template once for each object in an enumerable,
# you can use the +render_partials+ method:
#
#   each_partial([1,2,3], :foo) # uses _foo.erb
#
# This is basically equivalent to:
#
#   render_each([1,2,3], "_foo", local: :foo)
#
# This plugin depends on the render and render_each plugins.
#
# source://roda//lib/roda/plugins/partials.rb#31
module Roda::RodaPlugins::Partials
  class << self
    # Depend on the render plugin, passing received options to it.
    # Also depend on the render_each plugin.
    #
    # source://roda//lib/roda/plugins/partials.rb#34
    def load_dependencies(app, opts = T.unsafe(nil)); end
  end
end

# source://roda//lib/roda/plugins/partials.rb#39
module Roda::RodaPlugins::Partials::InstanceMethods
  # For each object in the given enumerable, render the given
  # template (prefixing the template filename with an underscore).
  #
  # source://roda//lib/roda/plugins/partials.rb#42
  def each_partial(enum, template, opts = T.unsafe(nil)); end

  # Renders the given template without a layout, but
  # prefixes the template filename to use with an
  # underscore.
  #
  # source://roda//lib/roda/plugins/partials.rb#53
  def partial(template, opts = T.unsafe(nil)); end

  private

  # Prefix the template base filename with an underscore.
  #
  # source://roda//lib/roda/plugins/partials.rb#64
  def partial_template_name(template); end
end

# The path plugin adds support for named paths.  Using the +path+ class method, you can
# easily create <tt>*_path</tt> instance methods for each named path.  Those instance
# methods can then be called if you need to get the path for a form action, link,
# redirect, or anything else.
#
# Additionally, you can call the +path+ class method with a class and a block, and it will register
# the class.  You can then call the +path+ instance method with an instance of that class, and it will
# execute the block in the context of the route block scope with the arguments provided to path. You
# can call the +url+ instance method with the same arguments as the +path+ method to get the full URL.
#
# Example:
#
#   plugin :path
#   path :foo, '/foo'
#   path :bar do |bar|
#     "/bar/#{bar.id}"
#   end
#   path Baz do |baz, *paths|
#     "/baz/#{baz.id}/#{paths.join('/')}"
#   end
#   path Quux do |quux, path|
#     "/quux/#{quux.id}/#{path}"
#   end
#   path 'FooBar', class_name: true do |foobar|
#     "/foobar/#{foobar.id}"
#   end
#
#   route do |r|
#     r.post 'foo' do
#       r.redirect foo_path # /foo
#     end
#
#     r.post 'bar' do
#       bar_params = r.params['bar']
#       if bar_params.is_a?(Hash)
#         bar = Bar.create(bar_params)
#         r.redirect bar_path(bar) # /bar/1
#       end
#     end
#
#     r.post 'baz' do
#       baz = Baz[1]
#       r.redirect path(baz, 'c', 'd') # /baz/1/c/d
#     end
#
#     r.post 'quux' do
#       quux = Quux[1]
#       r.redirect url(quux, '/bar') # http://example.com/quux/1/bar
#     end
#   end
#
# The path class method accepts the following options when not called with a class:
#
# :add_script_name :: Prefix the path generated with SCRIPT_NAME. This defaults to the app's
#                     :add_script_name option.
# :name :: Provide a different name for the method, instead of using <tt>*_path</tt>.
# :relative :: Generate paths relative to the current request instead of absolute paths by prepending
#              an appropriate prefix.  This implies :add_script_name.
# :url :: Create a url method in addition to the path method, which will prefix the string generated
#         with the appropriate scheme, host, and port.  If true, creates a <tt>*_url</tt>
#         method.  If a Symbol or String, uses the value as the url method name.
# :url_only :: Do not create a path method, just a url method.
#
# Note that if :add_script_name, :relative, :url, or :url_only is used, the path method will also create a
# <tt>_*_path</tt> private method.
#
# If the path class method is passed a string or symbol as the first argument, and the second argument
# is a hash with the :class_name option passed, the symbol/string is treated as a class name.
# This enables the use of class-based paths without forcing autoloads for the related
# classes.  If the plugin is not registering classes by name, this will use the symbol or
# string to find the related class.
#
# source://roda//lib/roda/plugins/path.rb#77
module Roda::RodaPlugins::Path
  class << self
    # Initialize the path classes when loading the plugin. Options:
    # :by_name :: Register classes by name, which is friendlier when reloading code (defaults to
    #             true in development mode)
    #
    # source://roda//lib/roda/plugins/path.rb#86
    def configure(app, opts = T.unsafe(nil)); end
  end
end

# source://roda//lib/roda/plugins/path.rb#97
module Roda::RodaPlugins::Path::ClassMethods
  # Freeze the path classes when freezing the app.
  #
  # source://roda//lib/roda/plugins/path.rb#104
  def freeze; end

  # Create a new instance method for the named path.  See plugin module documentation for options.
  #
  # @raise [RodaError]
  #
  # source://roda//lib/roda/plugins/path.rb#111
  def path(name, path = T.unsafe(nil), opts = T.unsafe(nil), &block); end

  # Return the block related to the given class, or nil if there is no block.
  #
  # source://roda//lib/roda/plugins/path.rb#210
  def path_block(klass); end

  # Hash of recognizes classes for path instance method.  Keys are classes, values are procs.
  #
  # source://roda//lib/roda/plugins/path.rb#99
  def path_classes; end
end

# source://roda//lib/roda/plugins/path.rb#78
Roda::RodaPlugins::Path::DEFAULT_PORTS = T.let(T.unsafe(nil), Hash)

# source://roda//lib/roda/plugins/path.rb#219
module Roda::RodaPlugins::Path::InstanceMethods
  # Return a path based on the class of the object.  The object passed must have
  # had its class previously registered with the application.  If the app's
  # :add_script_name option is true, this prepends the SCRIPT_NAME to the path.
  #
  # source://roda//lib/roda/plugins/path.rb#223
  def path(obj, *args, &block); end

  # Similar to #path, but returns a complete URL.
  #
  # source://roda//lib/roda/plugins/path.rb#237
  def url(*args, &block); end

  private

  # The string to prepend to the path to make the path a URL.
  #
  # source://roda//lib/roda/plugins/path.rb#244
  def _base_url; end
end

# Regexp for valid constant names, to prevent code execution.
#
# source://roda//lib/roda/plugins/path.rb#81
Roda::RodaPlugins::Path::VALID_CONSTANT_NAME_REGEXP = T.let(T.unsafe(nil), Regexp)

# The public plugin adds a +r.public+ routing method to serve static files
# from a directory.
#
# The public plugin recognizes the application's :root option, and defaults to
# using the +public+ subfolder of the application's +:root+ option.  If the application's
# :root option is not set, it defaults to the +public+ folder in the working
# directory.  Additionally, if a relative path is provided as the +:root+
# option to the plugin, it will be considered relative to the application's
# +:root+ option.
#
# Examples:
#
#   # Use public folder as location of files
#   plugin :public
#
#   # Use /path/to/app/static as location of files
#   opts[:root] = '/path/to/app'
#   plugin :public, root: 'static'
#
#   # Assuming public is the location of files
#   r.route do
#     # Make GET /images/foo.png look for public/images/foo.png
#     r.public
#
#     # Make GET /static/images/foo.png look for public/images/foo.png
#     r.on(:static) do
#       r.public
#     end
#   end
#
# source://roda//lib/roda/plugins/public.rb#43
module Roda::RodaPlugins::Public
  class << self
    # Use options given to setup a Rack::File instance for serving files. Options:
    # :default_mime :: The default mime type to use if the mime type is not recognized.
    # :gzip :: Whether to serve already gzipped files with a .gz extension for clients
    #          supporting gzipped transfer encoding.
    # :brotli :: Whether to serve already brotli-compressed files with a .br extension
    #            for clients supporting brotli transfer encoding.
    # :headers :: A hash of headers to use for statically served files
    # :root :: Use this option for the root of the public directory (default: "public")
    #
    # source://roda//lib/roda/plugins/public.rb#56
    def configure(app, opts = T.unsafe(nil)); end
  end
end

# source://roda//lib/roda/plugins/public.rb#45
Roda::RodaPlugins::Public::PARSER = T.let(T.unsafe(nil), URI::RFC2396_Parser)

# source://roda//lib/roda/plugins/public.rb#46
Roda::RodaPlugins::Public::RACK_FILES = Rack::Files

# source://roda//lib/roda/plugins/public.rb#67
module Roda::RodaPlugins::Public::RequestMethods
  # Serve files from the public directory if the file exists and this is a GET request.
  #
  # source://roda//lib/roda/plugins/public.rb#69
  def public; end

  private

  # Return whether the given path is a readable regular file.
  #
  # @return [Boolean]
  #
  # source://roda//lib/roda/plugins/public.rb#89
  def public_file_readable?(path); end

  # Return an array of segments for the given path, handling ..
  # and . components
  #
  # source://roda//lib/roda/plugins/public.rb#77
  def public_path_segments(path); end

  # Serve the given path using the given Rack::Files server.
  #
  # source://roda//lib/roda/plugins/public.rb#137
  def public_serve(server, path); end

  # source://roda//lib/roda/plugins/public.rb#116
  def public_serve_compressed(server, path, suffix, encoding); end

  # source://roda//lib/roda/plugins/public.rb#97
  def public_serve_with(server); end
end

# source://roda//lib/roda/plugins/public.rb#44
Roda::RodaPlugins::Public::SPLIT = T.let(T.unsafe(nil), Regexp)

# The render plugin adds support for template rendering using the tilt
# library.  Two methods are provided for template rendering, +view+
# (which uses the layout) and +render+ (which does not).
#
#   plugin :render
#
#   route do |r|
#     r.is 'foo' do
#       view('foo') # renders views/foo.erb inside views/layout.erb
#     end
#
#     r.is 'bar' do
#       render('bar') # renders views/bar.erb
#     end
#   end
#
# The +render+ and +view+ methods just return strings, they do not have
# side effects (unless the templates themselves have side effects).
# As Roda uses the routing block return value as the body of the response,
# in most cases you will call these methods as the last expression in a
# routing block to have the response body be the result of the template
# rendering.
#
# Because +render+ and +view+ just return strings, you can call them inside
# templates (i.e. for subtemplates/partials), or multiple times in the
# same route and combine the results together:
#
#   route do |r|
#     r.is 'foo-bars' do
#       @bars = Bar.where(:foo).map{|b| render(:bar, locals: {bar: b})}.join
#       view('foo')
#     end
#   end
#
# You can provide options to the plugin method:
#
#   plugin :render, engine: 'haml', views: 'admin_views'
#
# = Plugin Options
#
# The following plugin options are supported:
#
# :allowed_paths :: Set the template paths to allow.  Attempts to render paths outside
#                   of these paths will raise an error.  Defaults to the +:views+ directory.
# :cache :: nil/false to explicitly disable premanent template caching.  By default, permanent
#           template caching is disabled by default if RACK_ENV is development.  When permanent
#           template caching is disabled, for templates with paths in the file system, the
#           modification time of the file will be checked on every render, and if it has changed,
#           a new template will be created for the current content of the file.
# :cache_class :: A class to use as the template cache instead of the default.
# :check_paths :: Can be set to false to turn off template path checking.
# :engine :: The tilt engine to use for rendering, also the default file extension for
#            templates, defaults to 'erb'.
# :escape :: Use Erubi as the ERB template engine, and enable escaping by default,
#            which makes <tt><%= %></tt> escape output and  <tt><%== %></tt> not escape output.
#            If given, sets the <tt>escape: true</tt> option for all template engines, which
#            can break some non-ERB template engines.  You can use a string or array of strings
#            as the value for this option to only set the <tt>escape: true</tt> option for those
#            specific template engines.
# :layout :: The base name of the layout file, defaults to 'layout'.  This can be provided as a hash
#            with the :template or :inline options.
# :layout_opts :: The options to use when rendering the layout, if different from the default options.
# :template_opts :: The tilt options used when rendering all templates. defaults to:
# :engine_opts :: The tilt options to use per template engine.  Keys are
#                 engine strings, values are hashes of template options.
# :views :: The directory holding the view files, defaults to the 'views' subdirectory of the
#           application's :root option (the process's working directory by default).
#
# = Render/View Method Options
#
# Most of these options can be overridden at runtime by passing options
# to the +view+ or +render+ methods:
#
#   view('foo', engine: 'html.erb')
#   render('foo', views: 'admin_views')
#
# There are additional options to +view+ and +render+ that are
# available at runtime:
#
# :cache :: Set to false to not cache this template, even when
#           caching is on by default.  Set to true to force caching for
#           this template, even when the default is to not permantently cache (e.g.
#           when using the :template_block option).
# :cache_key :: Explicitly set the hash key to use when caching.
# :content :: Only respected by +view+, provides the content to render
#             inside the layout, instead of rendering a template to get
#             the content.
# :inline :: Use the value given as the template code, instead of looking
#            for template code in a file.
# :locals :: Hash of local variables to make available inside the template.
# :path :: Use the value given as the full pathname for the file, instead
#          of using the :views and :engine option in combination with the
#          template name.
# :scope :: The object in which context to evaluate the template.  By
#           default, this is the Roda instance.
# :template :: Provides the name of the template to use.  This allows you
#              pass a single options hash to the render/view method, while
#              still allowing you to specify the template name.
# :template_block :: Pass this block when creating the underlying template,
#                    ignored when using :inline.  Disables caching of the
#                    template by default.
# :template_class :: Provides the template class to use, instead of using
#                    Tilt or <tt>Tilt[:engine]</tt>.
#
# Here's an example of using these options:
#
#   view(inline: '<%= @foo %>')
#   render(path: '/path/to/template.erb')
#
# If you pass a hash as the first argument to +view+ or +render+, it should
# have either +:template+, +:inline+, +:path+, or +:content+ (for +view+) as
# one of the keys.
#
# = Speeding Up Template Rendering
#
# The render/view method calls are optimized for usage with a single symbol/string
# argument specifying the template name.  So for fastest rendering, pass only a
# symbol/string to render/view.  Next best optimized are template calls with a
# single :locals option.  Use of other options disables the compiled template
# method optimizations and can be significantly slower.
#
# If you must pass a hash to render/view, either as a second argument or as the
# only argument, you can speed things up by specifying a +:cache_key+ option in
# the hash, making sure the +:cache_key+ is unique to the template you are
# rendering.
#
# = Accepting Template Blocks in Methods
#
# If you are used to Rails, you may be surprised that this type of template code
# doesn't work in Roda:
#
#   <%= some_method do %>
#     Some HTML
#   <% end %>
#
# The reason this doesn't work is that this is not valid ERB syntax, it is Rails syntax,
# and requires attempting to parse the <tt>some_method do</tt> Ruby code with a regular
# expression.  Since Roda uses ERB syntax, it does not support this.
#
# In general, these methods are used to wrap the content of the block and
# inject the content into the output. To get similar behavior with Roda, you have
# a few different options you can use.
#
# == Directly Inject Template Output
#
# You can switch from a <tt><%=</tt> tag to using a <tt><%</tt> tag:
#
#   <% some_method do %>
#     Some HTML
#   <% end %>
#
# While this would output <tt>Some HTML</tt> into the template, it would not be able
# to inject content before or after the block.  However, you can use the inject_erb_plugin
# to handle the injection:
#
#   def some_method
#     inject_erb "content before block"
#     yield
#     inject_erb "content after block"
#   end
#
# If you need to modify the captured block before injecting it, you can use the
# capture_erb plugin to capture content from the template block, and modify that content,
# then use inject_erb to inject it into the template output:
#
#   def some_method(&block)
#     inject_erb "content before block"
#     inject_erb capture_erb(&block).upcase
#     inject_erb "content after block"
#   end
#
# This is the recommended approach for handling this type of method, if you want to keep
# the template block in the same template.
#
# == Separate Block Output Into Separate Template
#
# By moving the <tt>Some HTML</tt> into a separate template, you can render that
# template inside the block:
#
#  <%= some_method{render('template_name')} %>
#
# It's also possible to use an inline template:
#
#   <%= some_method do render(:inline=><<-END)
#     Some HTML
#     END
#   end %>
#
# This approach is useful if it makes sense to separate the template block into its
# own template. You lose the ability to use local variable from outside the
# template block inside the template block with this approach.
#
# == Separate Header and Footer
#
# You can define two separate methods, one that outputs the content before the block,
# and one that outputs the content after the block, and use those instead of a single
# call:
#
#   <%= some_method_before %>
#     Some HTML
#   <%= some_method_after %>
#
# This is the simplest option to setup, but it is fairly tedious to use.
#
# source://roda//lib/roda/plugins/render.rb#211
module Roda::RodaPlugins::Render
  class << self
    # Setup default rendering options.  See Render for details.
    #
    # source://roda//lib/roda/plugins/render.rb#232
    def configure(app, opts = T.unsafe(nil)); end

    # :nocov:
    #
    # source://roda//lib/roda/plugins/render.rb#220
    def tilt_template_compiled_method(template, locals_keys, scope_class); end
  end
end

# source://roda//lib/roda/plugins/render.rb#217
Roda::RodaPlugins::Render::COMPILED_METHOD_SUPPORT = T.let(T.unsafe(nil), TrueClass)

# source://roda//lib/roda/plugins/render.rb#426
module Roda::RodaPlugins::Render::ClassMethods
  # Return an Tilt::Template object based on the given opts and template_opts.
  #
  # source://roda//lib/roda/plugins/render.rb#445
  def create_template(opts, template_opts); end

  # If using compiled methods and there is an optimized layout, speed up
  # access to the layout method to improve the performance of view.
  #
  # source://roda//lib/roda/plugins/render.rb#430
  def freeze; end

  # Copy the rendering options into the subclass, duping
  # them as necessary to prevent changes in the subclass
  # affecting the parent class.
  #
  # source://roda//lib/roda/plugins/render.rb#458
  def inherited(subclass); end

  # A proc that returns content, used for inline templates, so that the template
  # doesn't hold a reference to the instance of the class
  #
  # source://roda//lib/roda/plugins/render.rb#451
  def inline_template_block(content); end

  # Return the render options for this class.
  #
  # source://roda//lib/roda/plugins/render.rb#469
  def render_opts; end

  private

  # Precompile the layout method, to reduce method calls to look it up at runtime.
  #
  # source://roda//lib/roda/plugins/render.rb#476
  def _freeze_layout_method; end
end

# source://roda//lib/roda/plugins/render.rb#495
module Roda::RodaPlugins::Render::InstanceMethods
  # Render the given template. See Render for details.
  #
  # source://roda//lib/roda/plugins/render.rb#497
  def render(template, opts = T.unsafe(nil), &block); end

  # Return the render options for the instance's class.
  #
  # source://roda//lib/roda/plugins/render.rb#509
  def render_opts; end

  # Render the given template. See Render for details.
  # Private alias for render.  Should be used by other plugins when they want to render a template
  # without a layout, as plugins can override render to use a layout.
  #
  # source://roda//lib/roda/plugins/render.rb#497
  def render_template(template, opts = T.unsafe(nil), &block); end

  # Render the given template.  If there is a default layout
  # for the class, take the result of the template rendering
  # and render it inside the layout.  Blocks passed to view
  # are passed to render when rendering the template.
  # See Render for details.
  #
  # source://roda//lib/roda/plugins/render.rb#518
  def view(template, opts = T.unsafe(nil), &block); end

  private

  # If there is an instance method for the template, return the instance
  # method symbol.  This optimization is only used for render/view calls
  # with a single string or symbol argument.
  #
  # source://roda//lib/roda/plugins/render.rb#554
  def _cached_template_method(template); end

  # The key to use in the template method cache for the given template.
  #
  # source://roda//lib/roda/plugins/render.rb#564
  def _cached_template_method_key(template); end

  # Return the instance method symbol for the template in the method cache.
  #
  # source://roda//lib/roda/plugins/render.rb#569
  def _cached_template_method_lookup(method_cache, template); end

  # Return a symbol containing the optimized layout method
  #
  # source://roda//lib/roda/plugins/render.rb#574
  def _layout_method; end

  # Use an optimized render path for templates with a hash of locals.  Returns the result
  # of the template render if the optimized path is used, or nil if the optimized
  # path is not used and the long method needs to be used.
  #
  # source://roda//lib/roda/plugins/render.rb#581
  def _optimized_render_method_for_locals(template, locals); end

  # Get the content for #view, or return nil to use the unoptimized approach. Only called if
  # a single argument is passed to view.
  #
  # source://roda//lib/roda/plugins/render.rb#622
  def _optimized_view_content(template); end

  # If caching templates, attempt to retrieve the template from the cache.  Otherwise, just yield
  # to get the template.
  #
  # source://roda//lib/roda/plugins/render.rb#663
  def cached_template(opts, &block); end

  # Given the template name and options, set the template class, template path/content,
  # template block, and locals to use for the render in the passed options.
  #
  # source://roda//lib/roda/plugins/render.rb#677
  def find_template(opts); end

  # Return a single hash combining the template and opts arguments.
  #
  # source://roda//lib/roda/plugins/render.rb#715
  def parse_template_opts(template, opts); end

  # The default render options to use.  These set defaults that can be overridden by
  # providing a :layout_opts option to the view/render method.
  #
  # source://roda//lib/roda/plugins/render.rb#730
  def render_layout_opts; end

  # Convert template options to single hash when rendering templates using render.
  #
  # source://roda//lib/roda/plugins/render.rb#653
  def render_template_opts(template, opts); end

  # Retrieve the Tilt::Template object for the given template and opts.
  #
  # source://roda//lib/roda/plugins/render.rb#735
  def retrieve_template(opts); end

  # The name to use for the template.  By default, just converts the :template option to a string.
  #
  # source://roda//lib/roda/plugins/render.rb#786
  def template_name(opts); end

  # The template path for the given options.
  #
  # source://roda//lib/roda/plugins/render.rb#791
  def template_path(opts); end

  # If a layout should be used, return a hash of options for
  # rendering the layout template.  If a layout should not be
  # used, return nil.
  #
  # source://roda//lib/roda/plugins/render.rb#805
  def view_layout_opts(opts); end
end

# source://roda//lib/roda/plugins/render.rb#216
Roda::RodaPlugins::Render::NO_CACHE = T.let(T.unsafe(nil), Hash)

# Wrapper object for the Tilt template, that checks the modified
# time of the template file, and rebuilds the template if the
# template file has been modified.  This is an internal class and
# the API is subject to change at any time.
#
# source://roda//lib/roda/plugins/render.rb#322
class Roda::RodaPlugins::Render::TemplateMtimeWrapper
  # @return [TemplateMtimeWrapper] a new instance of TemplateMtimeWrapper
  #
  # source://roda//lib/roda/plugins/render.rb#323
  def initialize(roda_class, opts, template_opts); end

  # Compile a method in the given module with the given name that will
  # call the compiled template method, updating the compiled template method
  #
  # source://roda//lib/roda/plugins/render.rb#377
  def define_compiled_method(roda_class, method_name, locals_keys = T.unsafe(nil)); end

  # If the template file has been updated, return true and update
  # the template object and the modification time. Other return false.
  #
  # source://roda//lib/roda/plugins/render.rb#360
  def if_modified; end

  # If the template file exists and the modification time has
  # changed, rebuild the template file, then call render on it.
  #
  # source://roda//lib/roda/plugins/render.rb#337
  def render(*args, &block); end

  # Return when the template was last modified.  If the template depends on any
  # other files, check the modification times of all dependencies and
  # return the maximum.
  #
  # source://roda//lib/roda/plugins/render.rb#350
  def template_last_modified; end

  private

  # Return the compiled method for the current template object.
  #
  # source://roda//lib/roda/plugins/render.rb#396
  def compiled_method(locals_keys = T.unsafe(nil), roda_class = T.unsafe(nil)); end

  # Return the lambda used to define the compiled template method.  This
  # is separated into its own method so the lambda does not capture any
  # unnecessary local variables
  #
  # source://roda//lib/roda/plugins/render.rb#403
  def compiled_method_lambda(roda_class, method_name, locals_keys = T.unsafe(nil)); end

  # Reset the template, done every time the template or one of its
  # dependencies is modified.
  #
  # source://roda//lib/roda/plugins/render.rb#421
  def reset_template; end
end

# The render_each plugin allows you to render a template for each
# value in an enumerable, returning the concatention of all of the
# template renderings.  For example:
#
#   render_each([1,2,3], :foo)
#
# will render the +foo+ template 3 times.  Each time the template
# is rendered, the local variable +foo+ will contain the given
# value (e.g. on the first rendering +foo+ is 1).
#
# You can pass additional render options via an options hash:
#
#   render_each([1,2,3], :foo, views: 'partials')
#
# One additional option supported by is +:local+, which sets the
# local variable containing the current value to use.  So:
#
#   render_each([1,2,3], :foo, local: :bar)
#
# Will render the +foo+ template, but the local variable used inside
# the template will be +bar+.  You can use <tt>local: nil</tt> to
# not set a local variable inside the template. By default, the
# local variable name is based on the template name, with any
# directories and file extensions removed.
#
# source://roda//lib/roda/plugins/render_each.rb#32
module Roda::RodaPlugins::RenderEach
  class << self
    # Load the render plugin before this plugin, since this plugin
    # calls the render method.
    #
    # source://roda//lib/roda/plugins/render_each.rb#35
    def load_dependencies(app); end
  end
end

# source://roda//lib/roda/plugins/render_each.rb#39
Roda::RodaPlugins::RenderEach::ALLOWED_KEYS = T.let(T.unsafe(nil), Array)

# source://roda//lib/roda/plugins/render_each.rb#41
module Roda::RodaPlugins::RenderEach::InstanceMethods
  # For each value in enum, render the given template using the
  # given opts.  The template and options hash are passed to +render+.
  # Additional options supported:
  # :local :: The local variable to use for the current enum value
  #           inside the template.  An explicit +nil+ value does not
  #           set a local variable.  If not set, uses the template name.
  #
  # source://roda//lib/roda/plugins/render_each.rb#48
  def render_each(enum, template, opts = T.unsafe(nil)); end

  private

  # If compiled method support is enabled in the render plugin, return the
  # method name to call to render the template.  Return false if not given
  # a string or symbol, or if compiled method support for this template has
  # been explicitly disabled.  Otherwise return nil.
  #
  # source://roda//lib/roda/plugins/render_each.rb#93
  def _cached_render_each_template_method(template); end

  # Use an optimized render for each value in the enum.
  #
  # source://roda//lib/roda/plugins/render_each.rb#105
  def _optimized_render_each(enum, optimized_template, as, locals); end

  # The default local variable name to use for the template, if the :local option
  # is not used when calling render_each.
  #
  # source://roda//lib/roda/plugins/render_each.rb#84
  def render_each_default_local(template); end
end

# The route_csrf plugin is the recommended plugin to use to support
# CSRF protection in Roda applications. This plugin allows you set
# where in the routing tree to enforce CSRF protection.  Additionally,
# the route_csrf plugin uses modern security practices.
#
# By default, the plugin requires tokens be specific to the request
# method and request path, so a CSRF token generated for one form will
# not be usable to submit a different form.
#
# This plugin also takes care to not expose the underlying CSRF key
# (except in the session), so that it is not possible for an attacker
# to generate valid CSRF tokens specific to an arbitrary request method
# and request path even if they have access to a token that is not
# specific to request method and request path.  To get this security
# benefit, you must ensure an attacker does not have access to the
# session.  Rack::Session::Cookie versions shipped with Rack before
# Rack 3 use signed sessions, not encrypted
# sessions, so if the attacker has the ability to read cookie data
# and you are using one of those Rack::Session::Cookie versions,
# it will still be possible
# for an attacker to generate valid CSRF tokens specific to arbitrary
# request method and request path.  Roda's session plugin uses
# encrypted sessions and therefore is safe even if the attacker can
# read cookie data.
#
# == Usage
#
# It is recommended to use the plugin defaults, loading the
# plugin with no options:
#
#   plugin :route_csrf
#
# This plugin supports the following options:
#
# :field :: Form input parameter name for CSRF token (default: '_csrf')
# :formaction_field :: Form input parameter name for path-specific CSRF tokens (used by the
#                      +csrf_formaction_tag+ method).  If present, this parameter should be
#                      submitted as a hash, keyed by path, with CSRF token values.
# :header :: HTTP header name for CSRF token (default: 'X-CSRF-Token')
# :key :: Session key for CSRF secret (default: '_roda_csrf_secret')
# :require_request_specific_tokens :: Whether request-specific tokens are required (default: true).
#                                     A false value will allow tokens that are not request-specific
#                                     to also work.  You should only set this to false if it is
#                                     impossible to use request-specific tokens.  If you must
#                                     use non-request-specific tokens in certain cases, it is best
#                                     to leave this option true by default, and override it on a
#                                     per call basis in those specific cases.
# :csrf_failure :: The action to taken if a request fails the CSRF check (default: :raise).  Options:
#                  :raise :: raise a Roda::RodaPlugins::RouteCsrf::InvalidToken exception
#                  :empty_403 :: return a blank 403 page (rack_csrf's default behavior)
#                  :clear_session :: Clear the current session
#                  Proc :: Treated as a routing block, called with request object
# :check_header :: Whether the HTTP header should be checked for the token value (default: false).
#                  If true, checks the HTTP header after checking for the form input parameter.
#                  If :only, only checks the HTTP header and doesn't check the form input parameter.
# :check_request_methods :: Which request methods require CSRF protection
#                           (default: <tt>['POST', 'DELETE', 'PATCH', 'PUT']</tt>)
# :upgrade_from_rack_csrf_key :: If provided, the session key that should be checked for the
#                                rack_csrf raw token.  If the session key is present, the value
#                                will be checked against the submitted token, and if it matches,
#                                the CSRF check will be passed.  Should only be set temporarily
#                                if upgrading from using rack_csrf to the route_csrf plugin, and
#                                should be removed as soon as you are OK with CSRF forms generated
#                                before the upgrade not longer being usable. The default rack_csrf
#                                key is <tt>'csrf.token'</tt>.
#
# The plugin also supports a block, in which case the block will be used
# as the value of the :csrf_failure option.
#
# == Methods
#
# This adds the following instance methods:
#
# check_csrf!(opts={}) :: Used for checking if the submitted CSRF token is valid.
#                         If a block is provided, it is treated as a routing block if the
#                         CSRF token is not valid.  Otherwise, by default, raises a
#                         Roda::RodaPlugins::RouteCsrf::InvalidToken exception if a CSRF
#                         token is necessary for the request and there is no token provided
#                         or the provided token is not valid. Options can be provided to
#                         override any of the plugin options for this specific call.
#                         The :token option can be used to specify the provided CSRF token
#                         (instead of looking for the token in the submitted parameters).
# csrf_formaction_tag(path, method='POST') :: An HTML hidden input tag string containing the CSRF token, suitable
#                                             for placing in an HTML form that has inputs that use formaction
#                                             attributes to change the endpoint to which the form is submitted.
#                                             Takes the same arguments as csrf_token.
# csrf_field :: The field name to use for the hidden tag containing the CSRF token.
# csrf_path(action) :: This takes an argument that would be the value of the HTML form's
#                      action attribute, and returns a path you can pass to csrf_token
#                      that should be valid for the form submission.  The argument should
#                      either be nil or a string representing a relative path, absolute
#                      path, or full URL (using appropriate URL encoding).
# csrf_tag(path=nil, method='POST') :: An HTML hidden input tag string containing the CSRF token, suitable
#                                      for placing in an HTML form.  Takes the same arguments as csrf_token.
# csrf_token(path=nil, method='POST') :: The value of the csrf token, in case it needs to be accessed
#                                        directly.  It is recommended to call this method with a
#                                        path, which will create a request-specific token.  Calling
#                                        this method without an argument will create a token that is
#                                        not specific to the request, but such a token will only
#                                        work if you set the :require_request_specific_tokens option
#                                        to false, which is a bad idea from a security standpoint.
# use_request_specific_csrf_tokens? :: Whether the plugin is configured to only support
#                                      request-specific tokens, true by default.
# valid_csrf?(opts={}) :: Returns whether the submitted CSRF token is valid (also true if
#                         the request does not require a CSRF token).  Takes same option hash
#                         as check_csrf!.
#
# This plugin also adds the following instance methods for compatibility with the
# older csrf plugin, but it is not recommended to use these methods in new code:
#
# csrf_header :: The header name to use for submitting the CSRF token via an HTTP header
#                (useful for javascript). Note that this plugin will not look in
#                the HTTP header by default, it will only do so if the :check_header
#                option is used.
# csrf_metatag :: An HTML meta tag string containing the CSRF token, suitable
#                 for placing in the page header.  It is not recommended to use
#                 this method, as the token generated is not request-specific and
#                 will not work unless you set the :require_request_specific_tokens option to
#                 false, which is a bad idea from a security standpoint.
#
# == Token Cryptography
#
# route_csrf uses HMAC-SHA-256 to generate all CSRF tokens.  It generates a random 32-byte secret,
# which is stored base64 encoded in the session.  For each CSRF token, it generates 31 bytes
# of random data.
#
# For request-specific CSRF tokens, this pseudocode generates the HMAC:
#
#   hmac = HMAC(secret, method + path + random_data)
#
# For CSRF tokens not specific to a request, this pseudocode generates the HMAC:
#
#   hmac = HMAC(secret, random_data)
#
# This pseudocode generates the final CSRF token in both cases:
#
#   token = Base64Encode(random_data + hmac)
#
# Using this construction for generating CSRF tokens means that generating any
# valid CSRF token without knowledge of the secret is equivalent to a successful generic attack
# on HMAC-SHA-256.
#
# By using an HMAC for tokens not specific to a request, it is not possible to use a
# valid CSRF token that is not specific to a request to generate a valid request-specific
# CSRF token.
#
# By including random data in the HMAC for all tokens, different tokens are generated
# each time, mitigating compression ratio attacks such as BREACH.
#
# source://roda//lib/roda/plugins/route_csrf.rb#158
module Roda::RodaPlugins::RouteCsrf
  class << self
    # source://roda//lib/roda/plugins/route_csrf.rb#179
    def configure(app, opts = T.unsafe(nil), &block); end

    # source://roda//lib/roda/plugins/route_csrf.rb#175
    def load_dependencies(app, opts = T.unsafe(nil)); end
  end
end

# Default CSRF option values
#
# source://roda//lib/roda/plugins/route_csrf.rb#160
Roda::RodaPlugins::RouteCsrf::DEFAULTS = T.let(T.unsafe(nil), Hash)

# source://roda//lib/roda/plugins/route_csrf.rb#193
module Roda::RodaPlugins::RouteCsrf::InstanceMethods
  # Check that the submitted CSRF token is valid, if the request requires a CSRF token.
  # If the CSRF token is valid or the request does not require a CSRF token, return nil.
  # Otherwise, if a block is given, treat it as a routing block and yield to it, and
  # if a block is not given, use the :csrf_failure option to determine how to handle it.
  #
  # source://roda//lib/roda/plugins/route_csrf.rb#198
  def check_csrf!(opts = T.unsafe(nil), &block); end

  # The name of the hidden input tag containing the CSRF token.  Also used as the name
  # for the meta tag.
  #
  # source://roda//lib/roda/plugins/route_csrf.rb#229
  def csrf_field; end

  # An HTML hidden input tag string containing the CSRF token, used for inputs
  # with formaction, so the same form can be used to submit to multiple endpoints
  # depending on which button was clicked.  See csrf_token for arguments, but the
  # path argument is required.
  #
  # source://roda//lib/roda/plugins/route_csrf.rb#267
  def csrf_formaction_tag(path, *args); end

  # The HTTP header name to use when submitting CSRF tokens in an HTTP header, if
  # such support is enabled (it is not by default).
  #
  # source://roda//lib/roda/plugins/route_csrf.rb#235
  def csrf_header; end

  # An HTML meta tag string containing a CSRF token that is not request-specific.
  # It is not recommended to use this, as it doesn't support request-specific tokens.
  #
  # source://roda//lib/roda/plugins/route_csrf.rb#241
  def csrf_metatag; end

  # Given a form action, return the appropriate path to use for the CSRF token.
  # This makes it easier to generate request-specific tokens without having to
  # worry about the different types of form actions (relative paths, absolute
  # paths, URLs, empty paths).
  #
  # source://roda//lib/roda/plugins/route_csrf.rb#249
  def csrf_path(action); end

  # An HTML hidden input tag string containing the CSRF token.  See csrf_token for
  # arguments.
  #
  # source://roda//lib/roda/plugins/route_csrf.rb#273
  def csrf_tag(*args); end

  # The value of the csrf token.  For a path specific token, provide a path
  # argument.  By default, it a path is provided, the POST request method will
  # be assumed.  To generate a token for a non-POST request method, pass the
  # method as the second argument.
  #
  # source://roda//lib/roda/plugins/route_csrf.rb#281
  def csrf_token(path = T.unsafe(nil), method = T.unsafe(nil)); end

  # Whether request-specific CSRF tokens should be used by default.
  #
  # @return [Boolean]
  #
  # source://roda//lib/roda/plugins/route_csrf.rb#288
  def use_request_specific_csrf_tokens?; end

  # Whether the submitted CSRF token is valid for the request.  True if the
  # request does not require a CSRF token.
  #
  # @return [Boolean]
  #
  # source://roda//lib/roda/plugins/route_csrf.rb#294
  def valid_csrf?(opts = T.unsafe(nil)); end

  private

  # Perform a constant-time comparison of the two strings, returning true if they match and false otherwise.
  #
  # source://roda//lib/roda/plugins/route_csrf.rb#367
  def csrf_compare(s1, s2); end

  # Return the HMAC-SHA-256 for the secret and the given arguments.
  #
  # source://roda//lib/roda/plugins/route_csrf.rb#372
  def csrf_hmac(random_data, method, path); end

  # Returns error message string if the CSRF token is not valid.
  # Returns nil if the CSRF token is valid.
  #
  # source://roda//lib/roda/plugins/route_csrf.rb#302
  def csrf_invalid_message(opts); end

  # Helper for getting the plugin options.
  #
  # source://roda//lib/roda/plugins/route_csrf.rb#362
  def csrf_options; end

  # If a secret has not already been specified, generate a random 32-byte
  # secret, stored base64 encoded in the session (to handle cases where
  # JSON is used for session serialization).
  #
  # source://roda//lib/roda/plugins/route_csrf.rb#379
  def csrf_secret; end
end

# Exception class raised when :csrf_failure option is :raise and
# a valid CSRF token was not provided.
#
# source://roda//lib/roda/plugins/route_csrf.rb#173
class Roda::RodaPlugins::RouteCsrf::InvalidToken < ::Roda::RodaError; end

# The run_append_slash plugin makes +r.run+ use +/+ as the +PATH_INFO+
# when calling the rack application if +PATH_INFO+ would be empty.
# Example:
#
#   route do |r|
#     r.on "a" do
#       r.run App
#     end
#   end
#
#   # without run_append_slash:
#   # GET /a => App gets "" as PATH_INFO
#   # GET /a/ => App gets "/" as PATH_INFO
#
#   # with run_append_slash:
#   # GET /a => App gets "/" as PATH_INFO
#   # GET /a/ => App gets "/" as PATH_INFO
#
# source://roda//lib/roda/plugins/run_append_slash.rb#23
module Roda::RodaPlugins::RunAppendSlash
  class << self
    # Set plugin specific options.  Options:
    # :use_redirects :: Whether to issue 302 redirects when appending the
    #                   trailing slash.
    #
    # source://roda//lib/roda/plugins/run_append_slash.rb#27
    def configure(app, opts = T.unsafe(nil)); end
  end
end

# source://roda//lib/roda/plugins/run_append_slash.rb#31
module Roda::RodaPlugins::RunAppendSlash::RequestMethods
  # Calls the given rack app. If the path matches the root of the app but
  # does not contain a trailing slash, a trailing slash is appended to the
  # path internally, or a redirect is issued when configured with
  # <tt>use_redirects: true</tt>.
  #
  # source://roda//lib/roda/plugins/run_append_slash.rb#36
  def run(*_arg0); end
end

# The sessions plugin adds support for sessions using cookies. It is the recommended
# way to support sessions in Roda applications.
#
# The session cookies are encrypted with AES-256-CTR using a separate encryption key per cookie,
# and then signed with HMAC-SHA-256.  By default, session data is padded to reduce information
# leaked based on the session size.
#
# Sessions are serialized via JSON, so session information should only store data that
# allows roundtrips via JSON (String, Integer, Float, Array, Hash, true, false, and nil).
# In particular, note that Symbol does not round trip via JSON, so symbols should not be
# used in sessions when this plugin is used.  This plugin sets the
# +:sessions_convert_symbols+ application option to +true+ if it hasn't been set yet,
# for better integration with plugins that can use either symbol or string session or
# flash keys.  Unlike Rack::Session::Cookie, the session is stored as a plain ruby hash,
# and does not convert all keys to strings.
#
# All sessions are timestamped and session expiration is enabled by default, with sessions
# being valid for 30 days maximum and 7 days since last use by default.  Session creation time is
# reset whenever the session is empty when serialized and also whenever +clear_session+
# is called while processing the request.
#
# Session secrets can be rotated.  See options below.
#
# The sessions plugin can transparently upgrade sessions from versions of Rack::Session::Cookie
# shipped with Rack before Rack 3,
# if the default Rack::Session::Cookie coder and HMAC are used, see options below.
# It is recommended to only enable transparent upgrades for a brief transition period,
# and remove support for them once old sessions have converted or timed out.
#
# If the final cookie is too large (>=4096 bytes), a Roda::RodaPlugins::Sessions::CookieTooLarge
# exception will be raised.
#
# = Required Options
#
# The session cookies this plugin uses are both encrypted and signed, so two separate
# secrets are used internally.  However, for ease of use, these secrets are combined into
# a single +:secret+ option.  The +:secret+ option must be a string of at least 64 bytes
# and should be randomly generated.  The first 32 bytes are used as the secret for the
# cipher, any remaining bytes are used for the secret for the HMAC.
#
# = Other Options
#
# :cookie_options :: Any cookie options to set on the session cookie. By default, uses
#                    <tt>httponly: true, path: '/', same_site: :lax</tt> so that the cookie is not accessible
#                    to javascript, allowed for all paths, and will not be used for cross-site non-GET requests
#                    that.  If the +:secure+ option is not present in the hash, then
#                    <tt>secure: true</tt> is also set if the request is made over HTTPS.  If this option is
#                    given, it will be merged into the default cookie options.
# :gzip_over :: For session data over this many bytes, compress it with the deflate algorithm (default: nil,
#               so never compress).  Note that compression should not be enabled if you are storing data in
#               the session derived from user input and also storing sensitive data in the session.
# :key :: The cookie name to use (default: <tt>'roda.session'</tt>)
# :max_seconds :: The maximum number of seconds to allow for total session lifetime, starting with when
#                 the session was originally created.  Default is <tt>86400*30</tt> (30 days). Can be set to
#                 +nil+ to disable session lifetime checks.
# :max_idle_seconds :: The maximum number of seconds to allow since the session was last updated.
#                      Default is <tt>86400*7</tt> (7 days).  Can be set to nil to disable session idleness
#                      checks.
# :old_secret :: The previous secret to use, allowing for secret rotation.  Must be a string of at least 64
#                bytes if given.
# :pad_size :: Pad session data (after possible compression, before encryption), to a multiple of this
#              many bytes (default: 32).  This can be between 2-4096 bytes, or +nil+ to disable padding.
# :per_cookie_cipher_secret :: Uses a separate cipher key for every cookie, with the key used generated using
#                              HMAC-SHA-256 of 32 bytes of random data with the default cipher secret. This
#                              offers additional protection in case the random initialization vector used when
#                              encrypting the session data has been reused. Odds of that are 1 in 2**64 if
#                              initialization vector is truly random, but weaknesses in the random number
#                              generator could make the odds much higher.  Default is +true+.
# :parser :: The parser for the serialized session data (default: <tt>JSON.method(:parse)</tt>).
# :serializer :: The serializer for the session data (default +:to_json.to_proc+).
# :skip_within :: If the last update time for the session cookie is less than this number of seconds from the
#                 current time, and the session has not been modified, do not set a new session cookie
#                 (default: 3600).
# :upgrade_from_rack_session_cookie_key :: The cookie name to use for transparently upgrading from
#                                          Rack::Session:Cookie (defaults to <tt>'rack.session'</tt>).
# :upgrade_from_rack_session_cookie_secret :: The secret for the HMAC-SHA1 signature when allowing
#                                             transparent upgrades from Rack::Session::Cookie. Using this
#                                             option is only recommended during a short transition period,
#                                             and is not enabled by default as it lowers security.
# :upgrade_from_rack_session_cookie_options :: Options to pass when deleting the cookie used by
#                                              Rack::Session::Cookie after converting it to use the session
#                                              cookies used by this plugin.
#
# = Not a Rack Middleware
#
# Unlike some other approaches to sessions, the sessions plugin does not use
# a rack middleware, so session information is not available to other rack middleware,
# only to the application itself, with the session not being loaded from the cookie
# until the +session+ method is called.
#
# If you need rack middleware to access the session information, then
# <tt>require 'roda/session_middleware'</tt> and <tt>use RodaSessionMiddleware</tt>.
# <tt>RodaSessionMiddleware</tt> passes the options given to this plugin.
#
# = Session Cookie Cryptography/Format
#
# Session cookies created by this plugin by default use the following format:
#
#   urlsafe_base64("\1" + random_data + IV + encrypted session data + HMAC)
#
# If +:per_cookie_cipher_secret+ option is set to +false+, an older format is used:
#
#   urlsafe_base64("\0" + IV + encrypted session data + HMAC)
#
# where:
#
# version :: 1 byte, currently must be 1 or 0, other values reserved for future expansion.
# random_data :: 32 bytes, used for generating the per-cookie secret
# IV :: 16 bytes, initialization vector for AES-256-CTR cipher.
# encrypted session data :: >=12 bytes of data encrypted with AES-256-CTR cipher, see below.
# HMAC :: 32 bytes, HMAC-SHA-256 of all preceding data plus cookie key (so that a cookie value
#         for a different key cannot be used even if the secret is the same).
#
# The encrypted session data uses the following format:
#
#   bitmap + creation time + update time + padding + serialized data
#
# where:
#
# bitmap :: 2 bytes in little endian format, lower 12 bits storing number of padding
#           bytes, 13th bit storing whether serialized data is compressed with deflate.
#           Bits 14-16 reserved for future expansion.
# creation time :: 4 byte integer in unsigned little endian format, storing unix timestamp
#                  since session initially created.
# update time :: 4 byte integer in unsigned little endian format, storing unix timestamp
#                since session last updated.
# padding :: >=0 padding bytes specified in bitmap, filled with random data, can be ignored.
# serialized data :: >=2 bytes of serialized data in JSON format.  If the bitmap indicates
#                    deflate compression, this contains the deflate compressed data.
#
# source://roda//lib/roda/plugins/sessions.rb#149
module Roda::RodaPlugins::Sessions
  class << self
    # Configure the plugin, see Sessions for details on options.
    #
    # source://roda//lib/roda/plugins/sessions.rb#179
    def configure(app, opts = T.unsafe(nil)); end

    # source://roda//lib/roda/plugins/sessions.rb#174
    def load_dependencies(app, opts = T.unsafe(nil)); end

    # Split given secret into a cipher secret and an hmac secret.
    #
    # @raise [RodaError]
    #
    # source://roda//lib/roda/plugins/sessions.rb#166
    def split_secret(name, secret); end
  end
end

# Exception class used when creating a session cookie that would exceed the
# allowable cookie size limit.
#
# source://roda//lib/roda/plugins/sessions.rb#162
class Roda::RodaPlugins::Sessions::CookieTooLarge < ::Roda::RodaError; end

# source://roda//lib/roda/plugins/sessions.rb#150
Roda::RodaPlugins::Sessions::DEFAULT_COOKIE_OPTIONS = T.let(T.unsafe(nil), Hash)

# source://roda//lib/roda/plugins/sessions.rb#151
Roda::RodaPlugins::Sessions::DEFAULT_OPTIONS = T.let(T.unsafe(nil), Hash)

# source://roda//lib/roda/plugins/sessions.rb#152
Roda::RodaPlugins::Sessions::DEFLATE_BIT = T.let(T.unsafe(nil), Integer)

# source://roda//lib/roda/plugins/sessions.rb#212
module Roda::RodaPlugins::Sessions::InstanceMethods
  # Clear data from the session, and update the request environment
  # so that the session cookie will use a new creation timestamp
  # instead of the previous creation timestamp.
  #
  # source://roda//lib/roda/plugins/sessions.rb#216
  def clear_session; end

  private

  # If session information has been set in the request environment,
  # update the rack response headers to set the session cookie in
  # the response.
  #
  # source://roda//lib/roda/plugins/sessions.rb#228
  def _roda_after_50__sessions(res); end
end

# source://roda//lib/roda/plugins/sessions.rb#153
Roda::RodaPlugins::Sessions::PADDING_MASK = T.let(T.unsafe(nil), Integer)

# source://roda//lib/roda/plugins/sessions.rb#235
module Roda::RodaPlugins::Sessions::RequestMethods
  # Persist the session data as a cookie.  If transparently upgrading from
  # Rack::Session::Cookie, mark the related cookie for expiration so it isn't
  # sent in the future.
  #
  # source://roda//lib/roda/plugins/sessions.rb#261
  def persist_session(headers, session); end

  # Load the session information from the cookie.  With the sessions
  # plugin, you must call this method to get the session, instead of
  # trying to access the session directly through the request environment.
  # For maximum compatibility with other software that uses rack sessions,
  # this method stores the session in 'rack.session' in the request environment,
  # but that does not happen until this method is called.
  #
  # source://roda//lib/roda/plugins/sessions.rb#242
  def session; end

  # The time the session was originally created. nil if there is no active session.
  #
  # source://roda//lib/roda/plugins/sessions.rb#247
  def session_created_at; end

  # The time the session was last updated. nil if there is no active session.
  #
  # source://roda//lib/roda/plugins/sessions.rb#253
  def session_updated_at; end

  private

  # Interpret given cookie data as a Rack::Session::Cookie
  # serialized session using the default Rack::Session::Cookie
  # hmac and coder.
  #
  # source://roda//lib/roda/plugins/sessions.rb#313
  def _deserialize_rack_session(data); end

  # Interpret given cookie data as a Rack::Session::Cookie
  #
  # source://roda//lib/roda/plugins/sessions.rb#347
  def _deserialize_session(data); end

  # Load the session by looking for the appropriate cookie, or falling
  # back to the rack session cookie if configured.
  #
  # source://roda//lib/roda/plugins/sessions.rb#290
  def _load_session; end

  # source://roda//lib/roda/plugins/sessions.rb#439
  def _serialize_session(session); end

  # If 'rack.errors' is set, write the error message to it.
  # This is used for errors that shouldn't be raised as exceptions,
  # such as improper session cookies.
  #
  # source://roda//lib/roda/plugins/sessions.rb#304
  def _session_serialization_error(msg); end
end

# source://roda//lib/roda/plugins/sessions.rb#154
Roda::RodaPlugins::Sessions::SESSION_CREATED_AT = T.let(T.unsafe(nil), String)

# source://roda//lib/roda/plugins/sessions.rb#158
Roda::RodaPlugins::Sessions::SESSION_DELETE_RACK_COOKIE = T.let(T.unsafe(nil), String)

# source://roda//lib/roda/plugins/sessions.rb#156
Roda::RodaPlugins::Sessions::SESSION_SERIALIZED = T.let(T.unsafe(nil), String)

# source://roda//lib/roda/plugins/sessions.rb#155
Roda::RodaPlugins::Sessions::SESSION_UPDATED_AT = T.let(T.unsafe(nil), String)

# source://roda//lib/roda/plugins/sessions.rb#157
Roda::RodaPlugins::Sessions::SESSION_VERSION_NUM = T.let(T.unsafe(nil), String)

# The status_handler plugin adds a +status_handler+ method which sets a
# block that is called whenever a response with the relevant response code
# with an empty body would be returned.
#
# This plugin does not support providing the blocks with the plugin call;
# you must provide them to status_handler calls afterwards:
#
#   plugin :status_handler
#
#   status_handler(403) do
#     "You are forbidden from seeing that!"
#   end
#
#   status_handler(404) do
#     "Where did it go?"
#   end
#
#   status_handler(405, keep_headers: ['Accept']) do
#     "Use a different method!"
#   end
#
# Before a block is called, any existing headers on the response will be
# cleared, unless the +:keep_headers+ option is used.  If the +:keep_headers+
# option is used, the value should be an array, and only the headers listed
# in the array will be kept.
#
# source://roda//lib/roda/plugins/status_handler.rb#31
module Roda::RodaPlugins::StatusHandler
  class << self
    # source://roda//lib/roda/plugins/status_handler.rb#35
    def configure(app); end
  end
end

# source://roda//lib/roda/plugins/status_handler.rb#32
Roda::RodaPlugins::StatusHandler::CLEAR_HEADERS = T.let(T.unsafe(nil), Proc)

# source://roda//lib/roda/plugins/status_handler.rb#39
module Roda::RodaPlugins::StatusHandler::ClassMethods
  # Freeze the hash of status handlers so that there can be no thread safety issues at runtime.
  #
  # source://roda//lib/roda/plugins/status_handler.rb#66
  def freeze; end

  # Install the given block as a status handler for the given HTTP response code.
  #
  # source://roda//lib/roda/plugins/status_handler.rb#41
  def status_handler(code, opts = T.unsafe(nil), &block); end
end

# source://roda//lib/roda/plugins/status_handler.rb#72
module Roda::RodaPlugins::StatusHandler::InstanceMethods
  private

  # If routing returns a response we have a handler for, call that handler.
  #
  # source://roda//lib/roda/plugins/status_handler.rb#76
  def _roda_after_20__status_handler(result); end
end

# Base class used for Roda requests.  The instance methods for this
# class are added by Roda::RodaPlugins::Base::RequestMethods, the
# class methods are added by Roda::RodaPlugins::Base::RequestClassMethods.
#
# source://roda//lib/roda/request.rb#21
class Roda::RodaRequest < ::Rack::Request
  include ::Roda::RodaPlugins::Base::RequestMethods
  extend ::Roda::RodaPlugins::Base::RequestClassMethods
end

# Base class used for Roda responses.  The instance methods for this
# class are added by Roda::RodaPlugins::Base::ResponseMethods, the class
# methods are added by Roda::RodaPlugins::Base::ResponseClassMethods.
#
# source://roda//lib/roda/response.rb#28
class Roda::RodaResponse
  include ::Roda::RodaPlugins::Base::ResponseMethods
  extend ::Roda::RodaPlugins::Base::ResponseClassMethods
end

# Contains constants for response headers.  This approach is used so that all
# headers used internally by Roda can be lower case on Rack 3, so that it is
# possible to use a plain hash of response headers instead of using Rack::Headers.
#
# source://roda//lib/roda/response.rb#12
module Roda::RodaResponseHeaders; end

# source://roda//lib/roda/response.rb#21
Roda::RodaResponseHeaders::ALLOW = T.let(T.unsafe(nil), String)

# source://roda//lib/roda/response.rb#21
Roda::RodaResponseHeaders::CACHE_CONTROL = T.let(T.unsafe(nil), String)

# source://roda//lib/roda/response.rb#21
Roda::RodaResponseHeaders::CONTENT_DISPOSITION = T.let(T.unsafe(nil), String)

# source://roda//lib/roda/response.rb#21
Roda::RodaResponseHeaders::CONTENT_ENCODING = T.let(T.unsafe(nil), String)

# source://roda//lib/roda/response.rb#21
Roda::RodaResponseHeaders::CONTENT_LENGTH = T.let(T.unsafe(nil), String)

# source://roda//lib/roda/response.rb#21
Roda::RodaResponseHeaders::CONTENT_SECURITY_POLICY = T.let(T.unsafe(nil), String)

# source://roda//lib/roda/response.rb#21
Roda::RodaResponseHeaders::CONTENT_SECURITY_POLICY_REPORT_ONLY = T.let(T.unsafe(nil), String)

# source://roda//lib/roda/response.rb#21
Roda::RodaResponseHeaders::CONTENT_TYPE = T.let(T.unsafe(nil), String)

# source://roda//lib/roda/response.rb#21
Roda::RodaResponseHeaders::ETAG = T.let(T.unsafe(nil), String)

# source://roda//lib/roda/response.rb#21
Roda::RodaResponseHeaders::EXPIRES = T.let(T.unsafe(nil), String)

# source://roda//lib/roda/response.rb#21
Roda::RodaResponseHeaders::LAST_MODIFIED = T.let(T.unsafe(nil), String)

# source://roda//lib/roda/response.rb#21
Roda::RodaResponseHeaders::LINK = T.let(T.unsafe(nil), String)

# source://roda//lib/roda/response.rb#21
Roda::RodaResponseHeaders::LOCATION = T.let(T.unsafe(nil), String)

# source://roda//lib/roda/response.rb#21
Roda::RodaResponseHeaders::PERMISSIONS_POLICY = T.let(T.unsafe(nil), String)

# source://roda//lib/roda/response.rb#21
Roda::RodaResponseHeaders::PERMISSIONS_POLICY_REPORT_ONLY = T.let(T.unsafe(nil), String)

# source://roda//lib/roda/response.rb#21
Roda::RodaResponseHeaders::SET_COOKIE = T.let(T.unsafe(nil), String)

# source://roda//lib/roda/response.rb#21
Roda::RodaResponseHeaders::TRANSFER_ENCODING = T.let(T.unsafe(nil), String)

# source://roda//lib/roda/response.rb#21
Roda::RodaResponseHeaders::VARY = T.let(T.unsafe(nil), String)

# The full version of Roda as a string.
#
# source://roda//lib/roda/version.rb#14
Roda::RodaVersion = T.let(T.unsafe(nil), String)

# The full version of Roda as a number (3.7.0 => 30070)
#
# source://roda//lib/roda/version.rb#17
Roda::RodaVersionNumber = T.let(T.unsafe(nil), Integer)
